---
title: 操作系统开发日志 02
date: 2023-01-06 16:57:14
tags: 操作系统
---

# 操作系统开发日志 02

从本篇开始我们开始正式设计和实现一个操作系统。

# 从哪里开始，到哪里结束

我们要开发的是一个可以在物理平台上运行的操作系统，虽说在开发与调试的过程中我们要使用虚拟机的形式启动，但是后面我们预定接入UEFI支持。而这个操作系统应该是个完整的操作系统，包含了系统的内核和系统应用，所以我们为了能在调试用的虚拟机里运行这个系统，我们得先为这个操作系统编写一个BootLoader。

# BootLoader开发 (1)

## Boot引导程序

计算机上电启动后，首先会经过BIOS上电自检。这时BIOS检测设备硬件是否存在问题，若没有，则将根据BIOS的启动项配置选择引导设备，目前BIOS支持的设备启动项有软盘启动、U盘启动、硬盘启动以及网络启动。一般BIOS会选择硬盘作为默认启动项，但我们先从软盘启动入手，后续加入U盘启动的支持。
## BIOS引导原理

当BIOS自检结束后会根据根据启动选项设置（这里指软驱启动）去选择启动设备，即检测软盘的第0磁头第0磁道第1扇区，是否以数值0x55和0xaa这两个字节作为结尾。如果是，则BIOS认为这个扇区是一个Boot Sector（引导扇区），进而把该扇区的数据复制到物理内存地址0x7c00处，随后将处理器的执行权移交给这段程序（跳转至0x7c00）地址处进行。

对于一个经典3.5英寸的1.44 MB的软盘而言，一个扇区的容量只有512 B,而且BIOS只负责加载这一个扇区的数据到物理内存中，512 B装不下一整个操作系统，甚至连获取硬件信息的检测程序都装不下，所以Boot引导程序只能作为一级助推器，将功能更强大的引导加载程序Loader加载到内存中，这也可以看作是硬件向软件移交控制权。一旦Loader引导加载程序开始执行，那么一切都交由我们编写的软件来控制。


引导扇区里的程序自然应该叫作引导程序，在BIOS向引导程序移交执行权之前，BIOS会对处理器进行初始化，这其中就包括处理器的代码段寄存器CS和指令指针寄存器IP。当BIOS跳转至引导程序时，CS寄存器和IP寄存器的值分别为0x0000和0x7c00。此时的处理器正处于实模式下，物理地址必须经过CS寄存器和IP寄存器转换才能得到，转换公式为：物理地区=CS<<4+IP，也就是物理地址0x7c00处。

因为引导程序只能装在一个扇区里，还要以0x55，、0xaa作为结束标识数据，那么引导程序的有效数据长度为512 B - 2 B = 510 B。这510 B虽然足够写一个加载Loader的汇编程序，但是Loader程序本身的存储和加载方式需要慎重考虑。

而考虑到如果把Loader引导加载程序直接保存到固定扇区中，最初的Boot引导程序会比较容易实现，但随着系统功能的增多，Loader和内核对扇区的需求量也会日益增长，每次向存储介质中写入Loader与内核，都得重新计算它们的起始扇区和占用扇区数，后续还得大幅修改Boot和Loader的代码，而且这种形式对每次修改完程序都急于看到执行结果的我们来说十分不便。

分析出上面这些弊端，我们决定一劳永逸地为软盘创建文件系统。

而且其实一个简单的文件系统并没有想象中那么复杂，像FAT12/16这类软盘型文件系统还是非常简单易懂的，所以我们将FAT12文件系统作为软盘文件系统以及后续的U盘文件系统再合适不过了。

## 写一个Boot引导程序

下面我们就开始用NASM汇编编写一个简单的Boot引导程序，在屏幕上显示一条日志信息，我们分段来解析代码的含义，以下是引导程序的寄存器初始化部分。

```nasm
    org 0x7c00

BaseOfStack equ 0x7c00

Label_Start:
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, BaseOfStack
```

在这段程序中，org是Origin的英文缩写，意思为起始地址或源地址。这条伪指令用于指定程序的起始地址，若程序未使用org伪指令，那么编译器会把地址0x0000作为程序的起始地址。程序的起始地址将主要影响绝对地址寻址指令，不同的起始地址会编译生成不同的绝对地址。因此，`org 0x7c00`的意思是，将程序的起始地址设置在0x7c00处。至于为什么是0x7c00,相比只有当年的BIOS工程师才知道。既然BIOS会加载引导程序至内存地址0x7c00处，我们就必须将引导程序的起始地址设置在此处，否则当程序访问绝对地址时很可能会出错。

下一条汇编代码`BaseOfStack equ 0x7c00`，这是一条等价语句，它将标识符BaseOfStack等价为数值0x7c00。equ伪指令的作用是让其左边的标识符代表右边的表达式。equ等价语句不会给标识符分配存储空间，而且标识符不能与其他符号同名，也不能被重新定义。类似于C语言中的预处理器语句`#define`。代码中的标识符BaseOfStack用于为栈指针寄存器SP提供栈基址。其实BIOS并未要求栈基址必须设置在0x7c00处，而且BIOS引导程序极少涉及栈操作，因此读者不必担心栈溢出问题。最后几条指令则是将CS寄存器的段基地址设置到DS、ES、SS等寄存器中，以及设置栈指针寄存器SP。

下面的代码是引导程序的主体代码，主要是通过BIOS中断服务程序INT 10h实现屏幕信息显示相关操作。INT 10h中断服务程序要求在调用时，必须向AH寄存器传入服务程序的主功能编号，再向其他寄存器传入参数。

```nasm
;======= clear screen
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0
    mov dx, 0184fh
;======= set focus
    mov ax, 0200h
    mov bx, 0000h
    mov dx, 0000h
    int 10h
;======= display on screen : Start Booting......
    mov ax, 1301h
    mov bx, 000fh
    mov dx, 0000h
    mov cx, 10
    push ax
    mov ax, ds
    mov es, ax
    pop ax
    mov bp, StartBootMessage
    int 10h
```
