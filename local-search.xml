<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kde-log-01</title>
    <link href="/2025/02/18/kde-log-01/"/>
    <url>/2025/02/18/kde-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>平板折腾日志 01</title>
    <link href="/2025/02/05/tablet-log-01/"/>
    <url>/2025/02/05/tablet-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期买冷一个x86寨板，型号是酷比魔方iwork 1X，4G内存，64G emmc闪存，出厂搭载windows1703。但是因为处理器是Intel Atom X5 Z8350，所以性能拉的一批。因为性能太拉了，所以想着刷成Linux系统。</p><h2 id="发行版选择"><a href="#发行版选择" class="headerlink" title="发行版选择"></a>发行版选择</h2><p>你问我喜欢哪个发行版？</p><p>那当然是Arch啦，Arch的pacman秒杀其他发行版，而且Arch社区资源丰富，Arch Wiki也很全，今天我们就来参照Arch Wiki的安装指南，安装Arch Linux到x86寨板上。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，你需要准备一张U盘来做Live USB启动盘，如果你没有U盘，可以购买一个。</p><p>然后我们需要去Arch Linux官方网站下载Arch Linux ISO镜像文件，下载地址：<a href="https://www.archlinux.org/download/">https://www.archlinux.org/download/</a></p><h2 id="制作Live-USB启动盘"><a href="#制作Live-USB启动盘" class="headerlink" title="制作Live USB启动盘"></a>制作Live USB启动盘</h2><p>制作Live USB启动盘的工具有很多，这里推荐一个叫做Rufus的工具，它可以用来制作各种启动盘，包括Live USB启动盘。</p><p>下载Rufus：<a href="https://rufus.ie/">https://rufus.ie/</a></p><p>下载完Rufus后，打开Rufus，选择Arch Linux ISO镜像文件，点击“选择镜像文件”，然后选择GPT分区格式，点击“开始”按钮。</p><p>等待Rufus制作完成，然后就可以开始准备刷入了。</p><h2 id="进入Live系统"><a href="#进入Live系统" class="headerlink" title="进入Live系统"></a>进入Live系统</h2><p>将制作好的Live USB启动盘插入x86寨板，开机后按F7进入BIOS启动选项，选择USB启动，然后我们就进入到了有三个选项的界面，选择第一个<code>Linux Installation Medium (x86_64)</code>，然后按回车键，进入到Arch Linux安装程序，这时BIOS会自动将U盘里的系统拷贝到内存中，自动启动Live系统，然后我们就可以开始安装Arch Linux了。</p><h2 id="安装Arch-Linux"><a href="#安装Arch-Linux" class="headerlink" title="安装Arch Linux"></a>安装Arch Linux</h2><p>第一步，联网，需要使用<code>iwctl</code>命令来连接到无线网络，输入以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">iwctl</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>平板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB设备描述符错误修复记录</title>
    <link href="/2024/12/31/usb-device-descriptor-error-fix-log/"/>
    <url>/2024/12/31/usb-device-descriptor-error-fix-log/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在调试USB设备时，发现设备描述符无法正常读取，导致设备无法正常工作。</p><p><img src="https://s2.loli.net/2024/12/31/zDI1e6yc4dfjG7m.png" alt="图 0">  </p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>推测是意外断电使得设备描述符损坏，导致系统无法正常加载对应的驱动程序。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>将USB设备从系统中卸载。</li><li>将USB设备插入安装有另一个系统（如<code>Linux</code>）的物理机中，使用<code>lsusb</code>命令查看设备描述符是否被正常识别。</li><li>如果设备描述符被正常识别，则该设备描述符已修复，可以直接将设备插回原系统。</li></ol><h2 id="该现象可能的原因"><a href="#该现象可能的原因" class="headerlink" title="该现象可能的原因"></a>该现象可能的原因</h2><p>Linux与Windows系统对USB设备驱动的加载方式不同，故可以让USB设备在Linux系统中加载驱动，让设备恢复正常的工作状态，从而修复设备描述符。该操作也同样适用于Linux系统，如果Linux上的USB设备描述符损坏，则可以尝试将其插入Windows系统，从而修复设备描述符。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript学习日志 01</title>
    <link href="/2024/12/31/typescript-log-01/"/>
    <url>/2024/12/31/typescript-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习Typescript"><a href="#为什么要学习Typescript" class="headerlink" title="为什么要学习Typescript"></a>为什么要学习Typescript</h2><p>TypeScript 是 JavaScript 的超集，它有着静态类型检查，可以避免很多运行时错误，避免了JavaScript中的一些坑，并且可以提升开发效率。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g typescript<br></code></pre></td></tr></table></figure><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>我们使用VSCode作为开发环境，VSCode内置了TypeScript支持，我们只需要创建一个目录，然后在里面新建一个<code>.ts</code>后缀的文件即可开始写代码。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们将下面的代码保存为<code>hello.ts</code>文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tsc hello.ts<br>node hello.js<br></code></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li><code>number</code>：数字类型，包括整数和浮点数</li><li><code>string</code>：字符串类型</li><li><code>boolean</code>：布尔类型</li><li><code>null</code>：空类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为随身WiFi编译主线内核</title>
    <link href="/2024/12/06/wifi-stick-log-02/"/>
    <url>/2024/12/06/wifi-stick-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在折腾随身 WiFi，发现内核版本比较老，于是想编译一个主线内核，但是随身 WiFi 的内核编译环境比较复杂，所以记录一下编译过程。</p><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>因为本文的内容较多，所以在开始之前，需要了解本次我们通过这篇文章是要得到什么东西：</p><ol><li>boot.img：存储着内核和对应机型的dtb（文章中为UZ801的dtb），用于引导和加载系统。</li><li>rootfs.img：用于存放系统。</li></ol><p>下图简要列出了整个流程：</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>下载内核源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要科学上网，或者使用国内镜像加速</span><br>git <span class="hljs-built_in">clone</span> https://github.com/msm8916-mailine/linux.git --depth=1<br></code></pre></td></tr></table></figure></li><li><p>下载编译工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 我使用WSL 2的Arch Linux来编译，所以我们使用pacman来安装工具链</span><br>sudo pacman -S base-devel aarch64-linux-gnu-gcc openssl minizip libidn11 bc git qemu-user-static-binfmt android-tools wget btrfs-progs<br></code></pre></td></tr></table></figure></li></ol><h2 id="配置-Makefile"><a href="#配置-Makefile" class="headerlink" title="配置 Makefile"></a>配置 Makefile</h2><blockquote><p>假设前面下载的内核源码是在<code>~/msm8916/linux</code>目录下。</p></blockquote><p>在当前终端中，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/msm8916/linux<br><span class="hljs-built_in">export</span> ARCH=arm64<br><span class="hljs-built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-<br></code></pre></td></tr></table></figure><p>然后，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make msm8916_defconfig<br>make menuconfig<br></code></pre></td></tr></table></figure><p>就会弹出一个配置菜单，我们需要修改以下几项：</p><ol><li>General setup -&gt; Local version - append to kernel release -&gt; 修改为自己想要显示在内核版本后的内容，比如<code>-blackwood416</code>。</li><li>General setup -&gt; Automatically append version information to the version string -&gt; 选择<code>n</code>，这会让内核版本信息更短，不然后面会加一长串的信息。</li></ol><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>使用以下命令开始编译，<code>-j$(nproc)</code>表示使用全部逻辑处理器来编译，这会使 CPU 满载，如果不希望满载可以根据自己的 CPU 更改为<code>-j4</code>或者<code>-j6</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><p>这个命令会自动编译内核镜像、模块以及 dtb 文件。</p><h2 id="制作系统镜像文件"><a href="#制作系统镜像文件" class="headerlink" title="制作系统镜像文件"></a>制作系统镜像文件</h2><ol><li><p>下载 Arch Linux ARM 根文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/msm8916<br>wget -c https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/os/ArchLinuxARM-aarch64-latest.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>创建系统镜像文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个 3372M 的镜像文件以匹配随身 WiFi 的存储空间大小</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=rootfs.img bs=1M count=3372<br></code></pre></td></tr></table></figure></li><li><p>初始化镜像文件的文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.btrfs rootfs.img<br></code></pre></td></tr></table></figure></li><li><p>挂载镜像文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> rootfs<br>sudo mount -o compress=zstd:1 rootfs.img rootfs<br></code></pre></td></tr></table></figure></li><li><p>解压根文件系统到镜像文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxpf ArchLinuxARM-aarch64-latest.tar.gz -C rootfs<br></code></pre></td></tr></table></figure></li><li><p>使用 chroot 进入镜像文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment"># 需要挂载一些必要的目录</span><br>sudo mount --<span class="hljs-built_in">bind</span> /dev ~/msm8916/dev<br>sudo mount -t devpts devpts ~/msm8916/rootfs/dev/pts -o gid=5,mode=620<br>sudo mount -t proc proc ~/msm8916/rootfs/proc<br>sudo mount -t sysfs sysfs ~/msm8916/rootfs/sys<br>sudo mount -t tmpfs tmpfs ~/msm8916/rootfs/run<br>sudo <span class="hljs-built_in">chroot</span> ~/msm8916/rootfs<br></code></pre></td></tr></table></figure></li><li><p>配置 pacman</p><p>开启并行下载和颜色显示，以及添加一些第三方软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /etc/pacman.conf<br><span class="hljs-comment"># 将下面这两行取消注释</span><br>Color<br>ParallelDownloads = 5<br><span class="hljs-comment"># 在文件末尾添加以下软件源</span><br>[arch4edu]<br>Server = https://mirrors.bfsu.edu.cn/arch4edu/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/<span class="hljs-variable">$arch</span><br>Server = https://mirror.autisten.club/arch4edu/<span class="hljs-variable">$arch</span><br>Server = https://arch4edu.keybase.pub/<span class="hljs-variable">$arch</span><br>Server = https://mirror.lesviallon.fr/arch4edu/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tencent.com/arch4edu/<span class="hljs-variable">$arch</span><br>SigLevel = Never<br>[archlinuxcn]<br>Server = https://mirrors.bfsu.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://repo.archlinuxcn.org/<span class="hljs-variable">$arch</span><br>SigLevel = Never<br>[blackarch]<br>Server = https://mirrors.ustc.edu.cn/blackarch/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/blackarch/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.aliyun.com/blackarch/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span><br>Server = https://www.blackarch.org/blackarch/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span><br>SigLevel = Never<br>[danctnix]<br>Server = https://p64.arikawa-hi.me/<span class="hljs-variable">$repo</span>/<span class="hljs-variable">$arch</span><br>SigLevel = Never<br></code></pre></td></tr></table></figure><p>更换国内源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /etc/pacman.d/mirrolist /etc/pacman.d/mirrolist.bak<br>nano /etc/pacman.d/mirrorlist<br> <span class="hljs-comment"># 更换成以下内容</span><br> <span class="hljs-comment">## Archlinux arm</span><br>Server = https://mirrors.ustc.edu.cn/archlinuxarm/<span class="hljs-variable">$arch</span>/<span class="hljs-variable">$repo</span><br>Server = https://mirror.archlinuxarm.org/<span class="hljs-variable">$arch</span>/<span class="hljs-variable">$repo</span><br>Server = https://mirrors.bfsu.edu.cn/archlinuxarm/<span class="hljs-variable">$arch</span>/<span class="hljs-variable">$repo</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/<span class="hljs-variable">$arch</span>/<span class="hljs-variable">$repo</span><br>Server = https://mirrors.163.com/archlinuxarm/<span class="hljs-variable">$arch</span>/<span class="hljs-variable">$repo</span><br></code></pre></td></tr></table></figure></li><li><p>配置网络</p><p>因为根文件系统默认的 DNS 是从 systemd 的文件链接过来，而我们使用 chroot，没有启动 systemd，所以需要手动配置 DNS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> /etc/resolv.conf<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nameserver 8.8.8.8&quot;</span> &gt; /etc/resolv.conf<br></code></pre></td></tr></table></figure></li><li><p>删除旧内核及固件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -R linux-aarch64 linux-firmware linux-firmware-whence<br></code></pre></td></tr></table></figure></li><li><p>更新系统</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key --init<br>pacman-key --populate<br>pacman -Syu<br></code></pre></td></tr></table></figure><ol start="11"><li>安装必要的软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S usbutils danctnix-usb-tethering <br></code></pre></td></tr></table></figure></li><li>开启 systemd 服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> usb-tethering<br>systemctl <span class="hljs-built_in">enable</span> NetworkManager<br>systemctl <span class="hljs-built_in">enable</span> ModemManager<br></code></pre></td></tr></table></figure></li><li>安装 vmlinuz 与内核模块</li><li>制作 initramfs 镜像文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kerver=$(<span class="hljs-built_in">ls</span> /usr/lib/modules)<br>mkinitcpio --generate /boot/initrd.img-<span class="hljs-variable">$kerver</span> --kernel <span class="hljs-variable">$kerver</span><br></code></pre></td></tr></table></figure><p>运行完上面的命令后还需要再开一个终端，在chroot外将镜像文件里的<code>initrd.img-*</code>拷贝出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> ~/msm8916/rootfs/boot/initrd.img-* ~/msm8916/initrd.img<br><span class="hljs-comment"># 更改一下所有者</span><br>sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">users</span>):$(<span class="hljs-built_in">groups</span>) ~/msm8916/initrd.img<br></code></pre></td></tr></table></figure><ol start="15"><li>取消挂载</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo umount ~/msm8916/rootfs/run<br>sudo umount ~/msm8916/rootfs/sys<br>sudo umount ~/msm8916/rootfs/proc<br>sudo umount ~/msm8916/rootfs/dev/pts<br>sudo umount ~/msm8916/rootfs/dev<br>sudo umount ~/msm8916/rootfs<br></code></pre></td></tr></table></figure><h2 id="制作-boot-img"><a href="#制作-boot-img" class="headerlink" title="制作 boot.img"></a>制作 boot.img</h2><p>这一步，我们需要之前编译出来的内核镜像、dtb 文件以及刚刚制作的 initramfs 镜像文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将它们都复制到 ~/msm8916/output 目录下</span><br><span class="hljs-built_in">mkdir</span> ~/msm8916/output<br><span class="hljs-built_in">cd</span> ~/msm8916/output<br><span class="hljs-built_in">cp</span> ~/msm8916/linux/arch/arm64/boot/Image.gz .<br><span class="hljs-built_in">cp</span> ~/msm8916/linux/arch/arm64/boot/dts/qcom/msm8916-yiming-uz801v3.dtb .<br><span class="hljs-built_in">mv</span> ~/msm8916/initrd.img .<br><br><span class="hljs-comment"># 合并内核镜像与dtb文件</span><br><span class="hljs-built_in">cat</span> Image.gz msm8916-yiming-uz801v3.dtb &gt; kernel-dtb<br><span class="hljs-comment"># 生成boot.img</span><br><span class="hljs-comment"># 其中root=UUID=2722581e-5f1b-4684-b07b-8d26bf6d8b6f 是根文件系统的UUID，可以通过以下命令获取：</span><br><span class="hljs-comment"># file ~/msm8916/rootfs.img</span><br>mkbootimg --base 0x80000000 \<br>--kernel_offset 0x00080000 \<br>--ramdisk_offset 0x02000000 \<br>--tags_offset 0x01e00000 \<br>--pagesize 2048 \<br>--second_offset 0x00f00000 \<br>--ramdisk initrd.img \<br>--cmdline <span class="hljs-string">&quot;earlycon root=UUID=2722581e-5f1b-4684-b07b-8d26bf6d8b6f console=ttyMSM0,115200 rw&quot;</span> \<br>--kernel kernel-dtb \<br>-o boot.img<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随身WiFi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随身WiFi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-log-04</title>
    <link href="/2024/12/01/os-log-04/"/>
    <url>/2024/12/01/os-log-04/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ASP.NET Native AOT 探索日志 01</title>
    <link href="/2024/11/28/native-aot-log-01/"/>
    <url>/2024/11/28/native-aot-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Native-AOT"><a href="#Native-AOT" class="headerlink" title="Native AOT"></a>Native AOT</h2><p>我们都知道 C#是对标 Java 的语言，所以 C#一直以来也是以 JIT（Just In Time）的方式运行，直到最近.NET 才真正实现了 C#的 AOT 编译。</p><p>有了 AOT 编译，C#可以直接被编译成对应平台的二进制程序，而无需依赖.Net Runtime 来运行。下面就来体验一下 Native AOT 吧。</p><h2 id="ASP-NET-Native-AOT"><a href="#ASP-NET-Native-AOT" class="headerlink" title="ASP.NET Native AOT"></a>ASP.NET Native AOT</h2><p>ASP.NET 也可以使用 Native AOT，这意味着我们可以不依赖.Net Runtime 在任意支持.Net 的平台上运行一个 ASP.NET Server。</p><p>官方提供了一些 Native AOT 模板，其中最实用的是<code>Minimal Web API for Native AOT</code>，它是一个最小的 ASP.NET Web API 项目，可以用来测试和验证 Native AOT 的功能。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先，我们安装.Net 8 以上的.Net SDK（我使用的是.Net 9），然后通过以下命令就可以创建一个名称为 test 的<code>Minimal Web API for Native AOT</code>项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet new webapiaot -n test<br></code></pre></td></tr></table></figure><p>为项目启用 Native AOT 的关键在于<code>.csproj</code>文件里的这个配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">PublishAot</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">PublishAot</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><p>要使用 Native AOT 来编译项目，我们需要使用<code>dotnet publish</code>命令，因为 Native AOT 的编译时间较长，所以微软官方推荐在发布应用时再进行 Native AOT 编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet publish -c Release -r win-x64<br></code></pre></td></tr></table></figure><p>运行完成后我们就可以在项目目录里的<code>/bin/Release/net9.0/win-x64/publish</code>目录下找到编译产物了。</p><p><img src="https://s2.loli.net/2024/12/02/Z1ymvzU2kdrQARo.png" alt="图 0"></p><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><p>很多时候，我们懒得将源码同步到容器或服务器上进行对应平台的编译，这时我们可以通过一些配置来实现在 Windows 上跨平台甚至是跨架构编译。</p><p>正常情况下，<code>dotnet publish -c Release -r linux-arm64</code>会报如下错误：</p><p><img src="https://s2.loli.net/2024/12/02/2GX4KCpL5EIlaNw.png" alt="图 1"></p><p>这时安装一个 NuGet 包，叫作<code>PublishAotCross</code>，这个包使用<code>Zig</code>来生成跨平台的二进制程序，让我们在<code>dotnet publish</code>的时候能使用<code>-r</code>参数来指定编译的平台。</p><p>我们在项目里安装<code>PublishAotCross</code>包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet add package PublishAotCross<br></code></pre></td></tr></table></figure><p>然后参考<a href="https://github.com/MichalStrehovsky/PublishAotCross">官方 GitHub</a>的 README，下载<code>Zig</code>并解压到任意目录，然后在 Path 环境变量中添加相关的路径以让其能被全局调用。</p><p><img src="https://s2.loli.net/2024/12/02/or9hLykebGmWtsS.png" alt="图 2"></p><p>现在执行<code>dotnet publish -c Release -r linux-arm64 /p:StripSymbols=false</code>，可以看到编译成功了：</p><p><img src="https://s2.loli.net/2024/12/02/xurEG6kKjpRTqbD.png" alt="图 3"></p><p>但是因为我们没有执行可选步骤，必须将 Debug 符号表嵌入到可执行文件中，导致了编译产物十分巨大。</p><p><img src="https://s2.loli.net/2024/12/02/AYJzFPyIfv7h3OX.png" alt="图 4"></p><p>这个可选步骤要执行起来其实也十分简单，那就是去下载一个 LLVM（压缩包大小约 1.3G），然后将里面的<code>llvm-objcopy</code>给放到<code>Zig</code>的安装目录下。</p><p>然后我们在项目的<code>.csproj</code>里添加如下选项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">StripSymbols</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">StripSymbols</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就可以不加<code>/p:StripSymbols=false</code>参数来编译，编译产物的大小也大大减小了。</p><p><img src="https://s2.loli.net/2024/12/02/JOEYULSr9cZXMdF.png" alt="图 5"></p><h2 id="优化程序体积"><a href="#优化程序体积" class="headerlink" title="优化程序体积"></a>优化程序体积</h2><p>我们发现这个编译产物的大小还是有那么一点大，那么有没有办法将它再缩小一点呢？</p><p>办法当然是有的，我们去下载一个叫作<code>PublishAotCompressed</code>的 NuGet 包，这个包使用<code>UPX</code>来压缩可执行文件。</p><p>我们使用<code>dotnet add package PublishAotCompressed</code>来安装这个包，然后在项目的<code>.csproj</code>里添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">PublishLzmaCompressed</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">PublishLzmaCompressed</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后我们再次尝试编译，程序的大小从 10MB 缩小到了 3MB。</p><p><img src="https://s2.loli.net/2024/12/02/QeS5WlLwEFVJZD1.png" alt="图 6"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Native AOT 是一个好东西，可以提高程序的性能和安全性，在启动速度方面比 JIT 要快上许多，但是它也存在一些问题，比如现阶段还不支持很多特性，关于这点我们以后再聊。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASP.NET NativeAOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Octave 学习日志 01</title>
    <link href="/2024/11/21/octave-log-01/"/>
    <url>/2024/11/21/octave-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Octave-是什么？"><a href="#Octave-是什么？" class="headerlink" title="Octave 是什么？"></a>Octave 是什么？</h2><p>Octave 是 GNU 旗下的一款开源的数值计算和图形绘制软件，支持多个领域的数值计算，可以说它是 Matlab 的开源免费的替代品。</p><h2 id="Octave-与-Matlab-的区别"><a href="#Octave-与-Matlab-的区别" class="headerlink" title="Octave 与 Matlab 的区别"></a>Octave 与 Matlab 的区别</h2><p>Octave 更加轻量化，Matlab 全量安装需要占用 20GB 的空间，而 Octave 本体+依赖只需要数百 MB 的空间。</p><p>Octave 语法大致与 Matlab 兼容，但在具体的函数和参数上有一些区别。</p><p>最重要的一点是，Octave 是免费的，而 Matlab 是收费的。</p><h2 id="Octave-下载与安装"><a href="#Octave-下载与安装" class="headerlink" title="Octave 下载与安装"></a>Octave 下载与安装</h2><p>我们在 Kali Linux 下安装 Octave，可以使用包管理器安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install octave -y<br></code></pre></td></tr></table></figure><p>安装完成后，我们可以使用命令 <code>octave</code> 打开 Octave 交互式环境。</p><h2 id="Octave-基本语法"><a href="#Octave-基本语法" class="headerlink" title="Octave 基本语法"></a>Octave 基本语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>Octave 支持 <code>disp</code> 函数输出变量的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs octave">disp(&quot;Hello, world!&quot;);<br></code></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Octave 支持 <code>input</code> 函数从用户输入获取值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs octave">name = input(&quot;What is your name? &quot;);<br>disp(&quot;Hello, &quot; + name + &quot;!&quot;);<br></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Octave 支持单行注释和多行注释，单行注释以 <code>%</code> 或 <code>#</code> 开头，多行注释以块的形式组织，以 <code>%&#123;</code> 和 <code>%&#125;</code> 包围（或者<code>#&#123;</code> 和 <code>#&#125;</code> 包围）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs octave">% This is a single line comment<br># This is also a single line comment<br><br>%&#123;<br>This is a multi-line comment<br>It can span multiple lines<br>%&#125;<br><br>#&#123;<br>This is also a multi-line comment<br>It can span multiple lines<br>#&#125;<br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Octave 中变量的声明和赋值使用 <code>=</code> 符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs octave">a = 1;<br>b = &quot;hello&quot;;<br>c = [1 2 3];<br></code></pre></td></tr></table></figure><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>Octave 中虽然语句后面的分号不是必须的，但是加上分号，Octave 就不会直接输出语句的结果，这样可以让输出更加整洁，减少冗余的输出。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>Octave 支持基本的算术运算、逻辑运算、比较运算、赋值运算、函数调用等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs octave">a = 1 + 2 * 3 / 4;<br>b = 1 == 2;<br>c = sin(pi / 4);<br>d = a = b;<br></code></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>Octave 支持 <code>if-else</code> 语句、<code>for</code>和<code>while</code>循环语句、函数定义语句等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs octave">if a &gt; 0<br>    disp(&quot;a is positive&quot;);<br>elseif a == 0<br>    disp(&quot;a is zero&quot;);<br>else<br>    disp(&quot;a is not positive&quot;);<br>end<br><br>for i = 1:10<br>    disp(i);<br>end<br><br>while a &lt; 10<br>    a = a + 1;<br>end<br><br>switch (X)<br>  case 1<br>    do_something ();<br>  case 2<br>    do_something_else ();<br>  otherwise<br>    do_something_completely_different ();<br>end<br><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Octave 支持自定义函数，函数的定义使用 <code>function</code> 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs octave">function myfun()<br>    disp(&quot;Hello, world!&quot;);<br>end<br></code></pre></td></tr></table></figure><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>Octave 支持绘制 2D 图形，包括折线图、散点图、直方图、饼图等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs octave">x = [1 2 3 4 5];<br>y = [1 4 9 16 25];<br>plot(x, y);<br></code></pre></td></tr></table></figure><h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><p>Octave 可以保存图片到文件，支持多种格式，包括 PNG、JPEG、EPS、PDF、SVG 等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs octave">print -dpng &quot;myplot.png&quot;<br></code></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>作为第一次接触 Octave 的记录，就先写这么多吧，后续再学习和分享一些高级用法。</p>]]></content>
    
    
    <categories>
      
      <category>科学计算与数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Octave</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习日志 03</title>
    <link href="/2024/11/16/os-log-03/"/>
    <url>/2024/11/16/os-log-03/</url>
    
    <content type="html"><![CDATA[<h2 id="BenOS-源码分析"><a href="#BenOS-源码分析" class="headerlink" title="BenOS 源码分析"></a>BenOS 源码分析</h2><p>上一篇我们运行成功的 BenOS，只是一个通过串口显示输出的最简单的裸机程序，我们后续会逐步扩展和丰富，让其具有进程调度、系统调用等现代操作系统的基本功能。</p><h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><p>因为我们写的是裸机程序，因此需要手动编写 Makefile 和链接脚本，链接这个过程平时是操作系统做的，所以裸机程序这个跟操作系统同级的程序需要自己手动链接。</p><p>对于任何一种可执行程序，不论是。elf 还是。exe，的都是由代码（.text）段、数据（.data）段、未初始化数据（.bss）段等段（sectioin）组成的。</p><p>链接脚本最终会把一大堆编译好的二进制文件（.o 文件）链接成一个可执行文件，这个可执行文件由总体的。text&#x2F;.data&#x2F;.bss 段描述。</p><p>下面看一下 BenOS 的链接脚本，名为<code>link.ld</code>，内容如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SECTIONS<br>&#123;<br>. = <span class="hljs-number">0x80000</span>;<br><span class="hljs-meta">.text</span>.<span class="hljs-keyword">boot </span>: &#123; *(<span class="hljs-meta">.text</span>.<span class="hljs-keyword">boot) </span>&#125;<br><span class="hljs-meta">.text</span> : &#123; *(<span class="hljs-meta">.text</span>) &#125;<br>.rodata : &#123; *(.rodata) &#125;<br><span class="hljs-meta">.data</span> : &#123; *(<span class="hljs-meta">.data</span>) &#125;<br>. = ALIGN(<span class="hljs-number">0x8</span>);<br><span class="hljs-keyword">bss_begin </span>= .;<br>.<span class="hljs-keyword">bss </span>: &#123; *(.<span class="hljs-keyword">bss*) </span>&#125;<br><span class="hljs-keyword">bss_end </span>= .;<br>&#125;<br></code></pre></td></tr></table></figure><p>第 1 行中，<code>SECTIONS</code>是链接脚本（Linker Script，简称 LS）语法中的关键命令，用来描述输出文件的内存布局。它告诉链接文件如何把输入文件的段映射到输出文件的各个段，如何将输入段整合为输出段，以及如何把输出段放入程序地址控件和进程地址空间。</p><p>在第 3 行中，<code>.</code>非常关键，它代表位置计数 (Location Counter,LC), 这里把<code>.text</code>段的<br>链接地址设置为 0x80000, 这里的链接地址指的是加载地址 (load address)。</p><p>在第 4 行中，输出文件的<code>.text.boot</code> 段内容由所有输入文件（其中的“*”可理解为所有的<code>.o</code> 文件，也就是二进制文件）的<code>.text.boot</code>段组成。</p><p>在第 5 行中，输出文件的<code>.text</code> 段内容由所有输入文件（其中的“*”可理解为所有的<code>.o</code>文件，也就是二进制文件）的<code>.text</code> 段组成。</p><p>在第 6 行中，输出文件的<code>.rodata</code> 段由所有输入文件的<code>.rodata</code> 段组成。</p><p>在第 7 行中，输出文件的<code>.data</code> 段由所有输入文件的<code>.data</code> 段组成。</p><p>在第 8 行中，设置为按 8 字节对齐。</p><p>在第 9~11 行中，定义了一个<code>.bss</code> 段。</p><p>因此，上述链接文件定义了如下几个段。</p><ul><li>.text.boot 段：启动首先要执行的代码。</li><li>.text 段：代码段。</li><li>.rodata 段：只读数据段。</li><li>.data 段：数据段。</li><li>.bss 段：包含未初始化的全局变量和静态变量。</li></ul><h2 id="启动（Boot）"><a href="#启动（Boot）" class="headerlink" title="启动（Boot）"></a>启动（Boot）</h2><p>下面我们来看用于启动的汇编代码<code>boot.S</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &quot;mm.h&quot;<br><br>.section &quot;.text.boot&quot;<br><br>.globl _start<br>_start:<br>mrsx0, mpidr_el1<br>andx0, x0,#0xFF// 检查处理器核心 ID<br>cbzx0, master// 除了 CPU0，其他 CPU 都会在这里死循环等待<br>bproc_hang<br><br>proc_hang: <br>b proc_hang<br><br>master:<br>adrx0, bss_begin<br>adrx1, bss_end<br>subx1, x1, x0<br>bl memzero<br><br>movsp, #LOW_MEMORY <br>blkernel_main<br>b proc_hang<br></code></pre></td></tr></table></figure><p>启动用的汇编代码不长，下面做简要分析。</p><p>在第 3 行中，把 <code>boot.S</code> 文件编译链接到<code>.text.boot</code> 段中。我们可以在链接文件 <code>link.ld</code> 中</p><p>把<code>.text.boot</code> 段链接到这个可执行文件的开头，这样当程序执行时将从这个段开始执行。</p><p>在第 6 行中，<code>_start</code> 为程序的入口点。</p><p>在第 7 行中，由于树莓派 4B 有 4 个 CPU 内核，但是本实验的裸机程序不希望 4 个 CPU 内核都运行，我们只想让第一个 CPU 内核运行起来。mpidr_el1 寄存器是表示处理器内核的编号。</p><p>在第 8 行中，<code>and</code> 指令用于完成与操作。</p><p>第 9 行，<code>cbz</code> 为比较并跳转指令。如果 X0 寄存器的值为 0, 则跳转到 <code>master</code> 标签处。若 X0 寄存器的值为 0, 则表示第 1 个 CPU 内核。其他 CPU 内核则跳转到 <code>proc_hang</code> 标签处。</p><p>在第 12 和 13 行，<code>proc_hang</code> 标签这里是死循环。</p><p>在第 15 行，对于 <code>master</code> 标签，只有第一个 CPU 内核才能运行到这里。</p><p>在第 16~19 行，初始化<code>.bss</code> 段。</p><p>在第 21 行中，使 SP 指向内存的 4 MB 地址处。树莓派至少有 1GB 内存，我们这个裸机程序用不到那么大的内存。</p><p>在第 22 行中，跳转到 C 语言的 <code>start_kernel</code> 函数，这里最重要的一步是设置 C 语言运行环境，即栈。</p><p>总之，上述汇编代码还是比较简单的，我们只做了 3 件事情。</p><ul><li>只让第一个 CPU 内核运行，让其他 CPU 内核进入死循环。</li><li>初始化。bss 段。</li><li>设置栈，跳转到 C 语言入口。</li></ul><h2 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h2><p>我们已经完成了启动，下面我们来看如何加载一个内核程序，在这个示例中，我们将加载一个名为 <code>kernel.c</code> 的 C 语言程序，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mini_uart.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    uart_init();<br>    uart_send_string(<span class="hljs-string">&quot;Welcome BenOS!\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <br>    &#123;<br>        uart_send(uart_recv());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序很简单，就是初始化串口并向串口中输出欢迎信息。</p><h2 id="串口驱动"><a href="#串口驱动" class="headerlink" title="串口驱动"></a>串口驱动</h2><p>我们还需要实现一个串口驱动，来驱动串口。</p><p>树莓派有两个串口设备：</p><ul><li>PL011 串口，在 BCM2711 芯片手册中简称 UART0，是一种全功能的串口设备。</li><li>Mini 串口，在 BCM2711 芯片手册中简称 UART1。</li></ul><p>我们使用 PL011 串口，因为 Mini 串口设备比较简单，不支持流量控制（flow control），在高速传输过程中还有可能丢包。</p><p>BCM2711 里有不少片内外设复用相同的 GPIO 接口，这称为 GPIO 可选功能配置（GPIO Alternative Function）。GPIO14 和 GPIO15 可以复用 UART0 和 UART1 串口的 TXD 引脚和 RXD 引脚，如下表所示：</p><table><thead><tr><th>GPIO</th><th>电平</th><th>可选项 0</th><th>可选项 1</th><th>可选项 2</th><th>可选项 3</th><th>可选项 4</th><th>可选项 5</th></tr></thead><tbody><tr><td>GPIO0</td><td>高</td><td>SDA0</td><td>SA5</td><td></td><td></td><td></td><td></td></tr><tr><td>GPIO1</td><td>高</td><td>SCL0</td><td>SA4</td><td></td><td></td><td></td><td></td></tr><tr><td>GPIO14</td><td>低</td><td>TXD0</td><td>SD6</td><td></td><td></td><td></td><td>TXD1</td></tr><tr><td>GPIO15</td><td>低</td><td>RXD0</td><td></td><td></td><td></td><td></td><td>RXD1</td></tr></tbody></table><p>BCM2711 提供了<code>GFPSELn</code>寄存器来设置 GPIO 可选功能配置，其中 GPFSEL0 同来配置 GPIO0<del>GPIO9，而 GPFSEL1 用来配置 GPIO10</del>GPIO19，以此类推。</p><p>其中，每个 GPIO 使用 3 位来表示不同的含义：</p><ul><li>000: 表示 GPIO 配置为输入。</li><li>001: 表示 GPIO 配置为输出。</li><li>100: 表示 GPIO 配置为可选项 0。</li><li>101: 表示 GPIO 配置为可选项 1。</li><li>110: 表示 GPIO 配置为可选项 2。</li><li>111: 表示 GPIO 配置为可选项 3。</li><li>011: 表示 GPIO 配置为可选项 4。</li><li>010: 表示 GPIO 配置为可选项 5。</li></ul><p>我们首先设置树莓派寄存器的基地址，在<code>include/asm/base.h</code>头文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span></span><br>_P_BASE_H<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BOARD_PI3B</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PBASE 0x3F000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PBASE 0xFE000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*_P_BASE_H */</span><br></code></pre></td></tr></table></figure><p>因为考虑到可能有人只有树莓派 3B，所以这里也定义了树莓派 3B 的基地址。</p><p>下面是 PL011 串口的初始化代码，是<code>pl_uart.c</code>文件中的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> selector;<br>selector = readl(GPFSEL1); selector &amp;= ~(<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);<br><span class="hljs-comment">/* 为 GPIO14 设置可选项 0*/</span><br>selector |= <span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">12</span>;<br>selector &amp;= ~(<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">15</span>);<br><span class="hljs-comment">/* 为 GPIO15 设置可选项 0 */</span><br>selector |= <span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">15</span>;<br>writel(selector, GPFSEL1);<br></code></pre></td></tr></table></figure><p>上述代码把 GPIO14 和 GPIO15 设置为可选项 0，也就是用作 PL011 串口的 TXD0 和 RXD0 引脚。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*设置 gpio14/15 为下拉状态*/</span><br>selector = readl(GPIO_PUP_PDN_CNTRL_REG0);<br>selector |= (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">30</span>) | (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">28</span>);<br>writel(selector, GPIO_PUP_PDN_CNTRL_REG0);<br></code></pre></td></tr></table></figure><p>通常 GPIO 引脚有 3 种状态——上拉（pull up）、下拉（pull down）以及连接（connect）。其中连接状态指的是既不上拉也不下拉，仅仅连接。上述代码就是把 GPIO14 和 GPIO15 设置为连接状态。</p><p>下面的代码用来初始化 PL011 串口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 暂时关闭串口 */</span><br>writel(<span class="hljs-number">0</span>, U_CR_REG);<br><span class="hljs-comment">/* 设置波特率 */</span><br>writel(<span class="hljs-number">26</span>, U_IBRD_REG);<br>writel(<span class="hljs-number">3</span>, U_FBRD_REG);<br><span class="hljs-comment">/* 使能 FIFO 设备 */</span><br>writel((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">5</span>), U_LCRH_REG);<br><span class="hljs-comment">/* 屏蔽中断 */</span><br>writel(<span class="hljs-number">0</span>, U_IMSC_REG);<br><span class="hljs-comment">/* 使能串口，打开收发功能 */</span><br>writel(<span class="hljs-number">1</span> | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">9</span>), U_CR_REG);<br></code></pre></td></tr></table></figure><p>接下来实现几个函数用来收发字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">uart_send</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (readl(U_FR_REG) &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>));<br>    writel(c, U_DATA_REG);<br>&#125;<br><span class="hljs-type">char</span> <span class="hljs-title function_">uart_recv</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (readl(U_FR_REG) &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>));<br>    <span class="hljs-keyword">return</span>(readl(U_DATA_REG) &amp; <span class="hljs-number">0xFF</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uart_send</code>和<code>uart_recv</code>分别用于在<code>while</code>循环中判断是否有数据需要发送和接收，这里只需要判断<code>U_FR_REG</code>寄存器的相应位即可。</p><p>代码里的一些函数比如<code>readl</code>和<code>writel</code>以及一些宏定义都在<code>include</code>下的其他头文件中。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>最后我们写好<code>Makefile</code>，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs makefile">board ?= rpi3<br>ARMGNU ?= aarch64-linux-gnu<br>COPS += -DCONFIG_BOARD_PI4B<br>QEMU_FLAGS += -machine raspi4<br>COPS += -g -Wall -nostdlib -nostdinc -Iinclude<br>ASMOPS = -g -Iinclude<br>BUILD_DIR = build<br>SRC_DIR = src<br><br>all : benos.bin<br><br>clean :<br>    rm -rf <span class="hljs-variable">$(BUILD_DIR)</span> *.bin<br><br><span class="hljs-variable">$(BUILD_DIR)</span>/%_c.o: <span class="hljs-variable">$(SRC_DIR)</span>/%.c<br>    mkdir -p $(@D)<br>    <span class="hljs-variable">$(ARMGNU)</span>-gcc <span class="hljs-variable">$(COPS)</span> -MMD -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-variable">$(BUILD_DIR)</span>/%_s.o: <span class="hljs-variable">$(SRC_DIR)</span>/%.S<br>    <span class="hljs-variable">$(ARMGNU)</span>-gcc <span class="hljs-variable">$(ASMOPS)</span> -MMD -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br>C_FILES = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(SRC_DIR)</span>/*.c)</span><br>ASM_FILES = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(SRC_DIR)</span>/*.S)</span><br>OBJ_FILES = $(C_FILES:<span class="hljs-variable">$(SRC_DIR)</span>/%.c=<span class="hljs-variable">$(BUILD_DIR)</span>/%_c.o)<br>OBJ_FILES += $(ASM_FILES:<span class="hljs-variable">$(SRC_DIR)</span>/%.S=<span class="hljs-variable">$(BUILD_DIR)</span>/%_s.o)<br>DEP_FILES = $(OBJ_FILES:%.o=%.d)<br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(DEP_FILES)</span><br><br><span class="hljs-section">benos.bin: <span class="hljs-variable">$(SRC_DIR)</span>/linker.ld <span class="hljs-variable">$(OBJ_FILES)</span></span><br>    <span class="hljs-variable">$(ARMGNU)</span>-ld -T <span class="hljs-variable">$(SRC_DIR)</span>/linker.ld -o <span class="hljs-variable">$(BUILD_DIR)</span>/benos.elf<br>    <span class="hljs-variable">$(ARMGNU)</span>-objcopy <span class="hljs-variable">$(BUILD_DIR)</span>/benos.elf -O binary benos.bin<br><br>QEMU_FLAGS += -nographic<br><br><span class="hljs-section">run:</span><br>    qemu-system-aarch64 <span class="hljs-variable">$(QEMU_FLAGS)</span> -kernel benos.bin<br><span class="hljs-section">debug:</span><br>    qemu-system-aarch64 <span class="hljs-variable">$(QEMU_FLAGS)</span> -kernel benos.bin -S -s<br></code></pre></td></tr></table></figure><p>COPS 和 ASMOPS 用来指定编译选项：</p><ul><li><code>-g</code>：在编译时加入调试符号表等信息，用于 gdb 调试。</li><li><code>-Wall</code>：显示所有警告信息。</li><li><code>-nostdlib</code>：不使用标准库。</li><li><code>-nostdinc</code>：不使用标准头文件。</li></ul><p>因为我们编译的是内核和 bootloader，所以不需要标准库和头文件，添加<code>-nostdlib</code>和<code>-nostdinc</code>选项使我们能用<code>-gnu</code>后缀的编译器来编译我们的程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们完成了操作系统的第一个裸机程序，并分析了其链接脚本和启动过程。下一篇我们开始深入了解 A64 指令集。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习日志 02</title>
    <link href="/2024/11/16/os-log-02/"/>
    <url>/2024/11/16/os-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="获取-BenOS"><a href="#获取-BenOS" class="headerlink" title="获取 BenOS"></a>获取 BenOS</h2><p>我们可以在 github 上找到 BenOS 的源码，<a href="https://github.com/runninglinuxkernel/arm64_programming_practice">地址</a></p><p>我们使用 git clone 命令下载到本地：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/runninglinuxkernel/arm64_programming_practice.git<br></code></pre></td></tr></table></figure><h2 id="编译-BenOS"><a href="#编译-BenOS" class="headerlink" title="编译 BenOS"></a>编译 BenOS</h2><p>我们需要安装编译工具链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install qemu-system-arm libncurses5-dev gcc-aarch64-linux-gnu build-essential git bison flex libssl-dev<br></code></pre></td></tr></table></figure><p>我们进入到<code>chapter02/lab01_hello_benos/BenOS</code>目录下，执行如下命令编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>然后目录下就会生成<code>benos.bin</code>可执行文件以及<code>benos.elf</code>文件，如果你的 qemu 支持树莓派 4，可直接使用<code>make run</code>命令来调用 qemu 虚拟机来模拟树莓派运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make run<br><span class="hljs-comment">#较新的 qemu 支持树莓派 4B： qemu-system-aarch64 -machine raspi4b -nographic -kernel benos.bin</span><br>Welcome BenOS!<br></code></pre></td></tr></table></figure><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p>我们可以使用 GDB 调试器来调试 BenOS，首先安装 gdb：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gdb-multiarch<br></code></pre></td></tr></table></figure><p>然后我们需要设置 qemu 的串口以及进入调试模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-arm -machine raspi4b -serial null -serial mon:stdio -nographic -kernel benos.bin -S -s<br><span class="hljs-comment"># 要退出 qemu，按下 Ctrl-A X 即可。</span><br></code></pre></td></tr></table></figure><p>接着我们在另一个终端执行 gdb 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb-multiarch --tui build/benos.elf<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/22/C2YMnSbBdZNmAya.png" alt="图 0">  </p><p>进入这个界面后回车，然后依次输入三个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gdb">target remote localhost:1234<br>b _start<br>c<br></code></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://s2.loli.net/2024/11/22/DCk16HrwtGXYizl.png" alt="图 1">  </p><p>然后我们在 gdb 里输入<code>s</code>命令来单步执行，可以看到程序的执行流程：</p><p><img src="https://s2.loli.net/2024/11/22/OMXEgWe1Hbq8xYP.png" alt="图 2">  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何获取 BenOS，编译，以及使用 GDB 调试器来调试 BenOS，下一篇我们来解构 BenOS 的源码。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>帝旭 UZ801 刷机教程</title>
    <link href="/2024/10/19/wifi-stick-log-01/"/>
    <url>/2024/10/19/wifi-stick-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul><li>一根帝旭 UZ801 随身 WiFi</li><li>一根 USB 延长线（用来连接电脑）</li><li>尖头的镊子（用来短接主板触电）（可选）</li><li>小型十字螺丝刀（用来拧螺丝）</li></ul><h2 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h2><p>我不喜欢使用别人封装的某某工具箱，所以我使用 QPT（Qualcomm Premium Tool）这种比较纯粹轻量的工具。</p><p>网上就能下载到，不过还需要 key 来激活（激活是记得把电脑调到静音，你会感谢我的）。</p><h2 id="进入-9008-模式"><a href="#进入-9008-模式" class="headerlink" title="进入 9008 模式"></a>进入 9008 模式</h2><p>首先，我们需要进入 9008 模式。</p><p>进入 9008 模式有两种方式：</p><ol><li>通过后台页面访问对应链接进入 adb，通过 adb 命令进入 9008 模式。</li><li>通过短接主板触点进入 9008 模式。</li></ol><blockquote><p>Tips: 判断棒子进没进入 9008 模式，最显著的特征就是棒子上的 LED 灯，有通电但是不亮的就是正在 9008 模式，反之有灯亮起（不论什么颜色）都代表棒子没有进入 9008。</p></blockquote><h3 id="通过-ADB-进入-9008-模式"><a href="#通过-ADB-进入-9008-模式" class="headerlink" title="通过 ADB 进入 9008 模式"></a>通过 ADB 进入 9008 模式</h3><p>连接棒子发出的 wifi，在浏览器访问<code>http://192.168.100.1</code>，在以下界面输入账号密码，默认账号密码都是<code>admin</code>。</p><p><img src="https://s2.loli.net/2024/11/28/oPuXkxGQMJdgEIB.png" alt="图 2">  </p><p>看到如下界面证明棒子运行正常。</p><p><img src="https://s2.loli.net/2024/11/28/FvqsHe5ugMXK8yL.png" alt="图 3">  </p><p>然后我们访问<code>http://192.168.100.1/usbdebug.html</code>，这个链接的界面是空白的，但是访问后棒子会自动重启并开启<code>adb</code>。</p><p>如果我们在电脑上安装了<code>adb</code>，我们就可以通过<code>adb devices</code>命令查看设备是否连接成功。</p><p><img src="https://s2.loli.net/2024/11/28/b7ZvHx2zE9ld3nm.png" alt="图 4">  </p><p>如果能识别到设备，那么我们可以使用命令<code>adb reboot edl</code>来进入 9008 模式。</p><p><img src="https://s2.loli.net/2024/11/28/NvKJOxYlW4k38Pb.png" alt="图 5">  </p><h3 id="通过短接触点进入-9008-模式"><a href="#通过短接触点进入-9008-模式" class="headerlink" title="通过短接触点进入 9008 模式"></a>通过短接触点进入 9008 模式</h3><p>首先，我们需要将棒子拆开，拧开螺丝，取出主板。</p><p>然后，我们找到主板上的这两个触点，使用尖头的镊子短接这两个触点，并连接电脑。</p><p><img src="https://s2.loli.net/2024/11/28/Rl7oZznSxEKP4r5.png" alt="图 6">  </p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="切换-SIM-卡（可选）"><a href="#切换-SIM-卡（可选）" class="headerlink" title="切换 SIM 卡（可选）"></a>切换 SIM 卡（可选）</h3><p>在刷机之前，我们需要通过棒子的后台界面将棒子的 SIM 卡切换到卡槽，不然刷完机，是无法使用我们自己的卡来上网的（因为 UZ801 无法在 OpenWrt&#x2F;Debian 中切卡）。</p><p>访问后台<code>http://192.168.100.1</code>，点击<code>高级设置</code>，在<code>SIM 卡信息</code>里，在<code>SIM 卡选择</code>里从<code>ESIM</code>换到<code>SIM</code>，切卡密码是<code>admin8888</code>。</p><p><img src="https://s2.loli.net/2024/11/28/SPp93Xg1wNdZvhe.png" alt="图 7">  </p><p><img src="https://s2.loli.net/2024/11/28/TULh2YXma5VJWy7.png" alt="图 8">  </p><p><img src="https://s2.loli.net/2024/11/28/cZNxvofnQP9q7OH.png" alt="图 9">  </p><h3 id="QPT-的备份"><a href="#QPT-的备份" class="headerlink" title="QPT 的备份"></a>QPT 的备份</h3><p>在刷入系统之前，建议备份好原有的数据。QPT 的备份分三种：Block0、Partition、Firmware，我们需要用到前两种。</p><ul><li><p>Block0：会备份 emmc 中的所有数据，建议首先备份，只会导出一个<code>.bin</code> 文件。</p></li><li><p>Partition：可以以分区的形式备份所有的分区，每个分区都会导出一个<code>.img</code> 或<code>.bin</code> 文件。</p></li><li><p>Firmware：用于备份系统的固件，但是 QPT 的 Firmware 备份有点问题，会报 Error，有些备份出来的文件也是空文件。</p></li></ul><blockquote><p>Tips：每次进入 9008 模式，只能进行一次 scan（扫描）或者 read（读取）操作，所以我们需要进入 9008 模式两次才能完成 Block0 和 Partition 备份。</p></blockquote><h3 id="Block0-备份"><a href="#Block0-备份" class="headerlink" title="Block0 备份"></a>Block0 备份</h3><p>我们一定要首先进行 Block0 备份，否则一旦刷机过程出错，我们就无法恢复到最开始的状态以便重新开始了。</p><p>进入 9008 模式，打开 QPT，选择<code>Block0</code>选项卡，点击<code>Read( 9008 )</code>，。</p><p><img src="https://s2.loli.net/2024/11/28/WTFuphcUsVY2Jdm.png" alt="图 1">  </p><h3 id="Partition-备份"><a href="#Partition-备份" class="headerlink" title="Partition 备份"></a>Partition 备份</h3><p>进入 9008 模式，打开 QPT，选择<code>partition</code>选项卡，选择<code>scan</code>后点击红色的<code>DoJob</code>，待读取出全部分区后，选择第一项<code>modem</code>分区，选择<code>backup</code>，<code>DoJob</code>，然后选择备份文件夹，等待备份完成。</p><p><img src="https://s2.loli.net/2024/12/02/IHvJkqVPTA6WUD4.png" alt="图 11">  </p><p><img src="https://s2.loli.net/2024/12/02/B9FWblGj3rn6Aai.png" alt="图 12">  </p><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>我们首先需要下载对应板号的系统，你要刷 OP 就找 OP 的系统，要刷 Debian 就找 Debian 的系统，这里我以刷入 Debian 为例。</p><h3 id="下载系统"><a href="#下载系统" class="headerlink" title="下载系统"></a>下载系统</h3><h4 id="OpenWrt"><a href="#OpenWrt" class="headerlink" title="OpenWrt"></a>OpenWrt</h4><p>这里以苏苏小亮亮的 OpenWrt 为例，访问 <a href="https://www.kancloud.cn/a813630449/ufi_car/2792820">这里</a> 找到下载地址。</p><h4 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h4><p>这里推荐下载 js 佬的超频版 Debian，可以充分发挥出棒子的性能，而且系统里没有什么乱七八糟的东西。可以在 <a href="https://www.coolapk.com/feed/41664623?shareKey=NzQzOTdlZjRlMzk2Njc0ODIyMjA~&shareUid=31652160&shareFrom=com.coolapk.market_14.6.0">这篇帖子</a> 里找到下载地址。</p><h3 id="刷入系统"><a href="#刷入系统" class="headerlink" title="刷入系统"></a>刷入系统</h3><h4 id="进入-fastboot-的两种方式"><a href="#进入-fastboot-的两种方式" class="headerlink" title="进入 fastboot 的两种方式"></a>进入 fastboot 的两种方式</h4><ol><li>使用<code>adb reboot bootloader</code>命令进入 fastboot 模式，跟 adb 一样，我们也可以通过<code>fastboot devices</code>来查看设备是否进入了 fastboot 模式。</li><li>在 9008 模式时用 QPT 格式化<code>boot</code>分区，重启后系统会因为找不到<code>boot</code>分区而自动进入 fastboot 模式。</li></ol><h4 id="OpenWrt-1"><a href="#OpenWrt-1" class="headerlink" title="OpenWrt"></a>OpenWrt</h4><p>苏苏小亮亮包里的<code>flash.bat</code>写的有些问题，以下是我修改后的版本：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span> OpenStick Bootloader<br><span class="hljs-built_in">echo</span> please make sure your device <span class="hljs-keyword">in</span> fastboot <span class="hljs-built_in">mode</span><br><span class="hljs-built_in">pause</span><br>fastboot <span class="hljs-built_in">erase</span> boot<br>fastboot flash aboot aboot.bin<br>fastboot reboot<br><span class="hljs-built_in">echo</span> when detected a fastboot device<br><span class="hljs-built_in">pause</span><br>fastboot oem dump fsc &amp;&amp; fastboot get_staged fsc.bin<br>fastboot oem dump fsg &amp;&amp; fastboot get_staged fsg.bin<br>fastboot oem dump modemst1 &amp;&amp; fastboot get_staged modemst1.bin<br>fastboot oem dump modemst2 &amp;&amp; fastboot get_staged modemst2.bin<br>fastboot <span class="hljs-built_in">erase</span> boot<br>fastboot reboot bootloader<br><span class="hljs-built_in">echo</span> when detected a fastboot device<br><span class="hljs-built_in">pause</span><br>fastboot flash partition gpt_both0.bin<br>fastboot flash hyp hyp.mbn<br>fastboot flash rpm rpm.mbn<br>fastboot flash sbl1 sbl1.mbn<br>fastboot flash tz tz.mbn<br>fastboot flash fsc fsc.bin<br>fastboot flash fsg fsg.bin<br>fastboot flash modemst1 modemst1.bin<br>fastboot flash modemst2 modemst2.bin<br>fastboot flash aboot aboot.bin<br>fastboot flash cdt sbc_1.<span class="hljs-number">0</span>_8016.bin<br>fastboot <span class="hljs-built_in">erase</span> boot<br>fastboot <span class="hljs-built_in">erase</span> rootfs<br>fastboot reboot<br><span class="hljs-built_in">echo</span> flashing OpenWrt!<br><span class="hljs-built_in">echo</span> when detected a fastboot device<br><span class="hljs-built_in">pause</span><br>fastboot flash boot boot.img<br>fastboot -S <span class="hljs-number">200</span>m flash rootfs rootfs.img<br>fastboot reboot<br><span class="hljs-built_in">echo</span> all done!!<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>你可以把<code>flash.bat</code>改成我上面这样，然后运行刷入即可。</p><h4 id="Debian-1"><a href="#Debian-1" class="headerlink" title="Debian"></a>Debian</h4><p>没啥好说的，运行<code>一键刷入工具。bat</code>，然后通过输入数字来选择对应的超频频率就可以了，<code>释放内存</code>版是阉割了 SIM 卡上网能力，所以如果你要用 SIM 卡槽的功能就不要刷<code>释放内存</code>版。</p><h2 id="连接系统"><a href="#连接系统" class="headerlink" title="连接系统"></a>连接系统</h2><h3 id="Windows设备驱动"><a href="#Windows设备驱动" class="headerlink" title="Windows设备驱动"></a>Windows设备驱动</h3><p>我们需要确保我们连接到棒子是用到<code>Microsoft</code>的<code>远程NDIS兼容设备</code>这个驱动，否则我们无法让棒子以NDIS模式连接到 Windows。</p><p>使用<code>Win + X M</code>快捷键打开设备管理器，如果你的设备管理器在刷完OpenWrt&#x2F;Debian后出现了如下的设备，那么你需要调整该设备的驱动。</p><p><img src="https://s2.loli.net/2024/12/02/peQOt1Kdk6sIVAW.png" alt="图 13">  </p><p>我们右键卸载设备并删除它的驱动程序。</p><p><img src="https://s2.loli.net/2024/12/02/UOlYRbrKHxJ357z.png" alt="图 14">  </p><p>拔插一下棒子（重启），然后你会在设备管理器看到这样一个设备或者未知设备。</p><p><img src="https://s2.loli.net/2024/12/02/qN8E7SLRrn1aPzy.png" alt="图 15">  </p><p>我们右键更新它的驱动，点击下面的<code>浏览我的电脑以查找驱动程序</code>。</p><p><img src="https://s2.loli.net/2024/12/02/MuXqC3hTwpBmVeA.png" alt="图 16">  </p><p>然后点击<code>让我从计算机上的可用驱动程序列表中选取</code>，然后点击下一步。</p><p><img src="https://s2.loli.net/2024/12/02/wMemCDLNK5kgGyI.png" alt="图 17">  </p><p>下滑找到<code>网络适配器</code>，然后点击下一步。</p><p><img src="https://s2.loli.net/2024/12/02/TZJ9lAPrt2kwM5y.png" alt="图 18">  </p><p>找到<code>厂商</code>为<code>Microsoft</code>的驱动，在右边的列表里找到<code>远程NDIS兼容设备</code>，然后点击下一步。</p><p><img src="https://s2.loli.net/2024/12/02/7s6dqXBeCjuYvPO.png" alt="图 19">  </p><p>这个弹窗选择<code>是</code>，然后驱动就换好了。</p><p><img src="https://s2.loli.net/2024/12/02/IbqtECfPO6o8pxz.png" alt="图 20">  </p><p>这时在设备管理器的<code>网络适配器</code>栏目下应该能找到设备名为<code>远程NDIS兼容设备</code>的设备，这个就是我们的棒子。</p><p><img src="https://s2.loli.net/2024/12/02/TSDOGhbXRQUrz1p.png" alt="图 21">  </p><h3 id="OpenWrt-2"><a href="#OpenWrt-2" class="headerlink" title="OpenWrt"></a>OpenWrt</h3><p>OpenWrt作为路由器系统是有Web后台的，完成驱动安装后，浏览器访问<code>http://192.168.1.1</code>，登录<code>root</code>用户，默认没有密码。</p><p><img src="https://s2.loli.net/2024/12/02/WeMky1EJOqup4nw.png" alt="图 22">  </p><h3 id="Debian-2"><a href="#Debian-2" class="headerlink" title="Debian"></a>Debian</h3><p>Debian 没有 Web 后台，需要使用 ssh 连接，<code>root</code>的默认密码是<code>1313144</code>。</p><p>我个人现在使用<code>WindTerm</code>来连接 ssh，你也可以使用<code>Putty</code>、<code>MobaXterm</code>等工具，如果你喜欢纯命令行操作那么直接用<code>Windows 可选功能</code>里安装的<code>OpenSSH 客户端</code>也可以。</p><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><h3 id="OpenWrt-更新"><a href="#OpenWrt-更新" class="headerlink" title="OpenWrt 更新"></a>OpenWrt 更新</h3><p>更新系统，截至2024年12月2日，这个OpenWrt版本无法直接用<code>opkg update</code>更新软件源。</p><p>我们在终端里<code>vi /etc/opkg/distfeeds.conf</code>，会显示以下内容：</p><p><img src="https://s2.loli.net/2024/12/02/42PsoBXrlOihv31.png" alt="图 24">  </p><p>将里面的链接换成可以用的链接。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">src<span class="hljs-regexp">/gz handsomemod_core https:/</span><span class="hljs-regexp">/downloads.immortalwrt.org/</span>releases<span class="hljs-regexp">/23.05.4/</span>targets<span class="hljs-regexp">/armsr/</span>armv8/packages<br>src<span class="hljs-regexp">/gz handsomemod_base https:/</span><span class="hljs-regexp">/downloads.immortalwrt.org/</span>releases<span class="hljs-regexp">/23.05.4/</span>packages<span class="hljs-regexp">/aarch64_cortex-a53/</span>base<br>src<span class="hljs-regexp">/gz handsomemod_luci https:/</span><span class="hljs-regexp">/downloads.immortalwrt.org/</span>releases<span class="hljs-regexp">/23.05.4/</span>packages<span class="hljs-regexp">/aarch64_cortex-a53/</span>luci<br>src<span class="hljs-regexp">/gz handsomemod_packages https:/</span><span class="hljs-regexp">/downloads.immortalwrt.org/</span>releases<span class="hljs-regexp">/23.05.4/</span>packages<span class="hljs-regexp">/aarch64_cortex-a53/</span>packages<br>src<span class="hljs-regexp">/gz handsomemod_routing https:/</span><span class="hljs-regexp">/downloads.immortalwrt.org/</span>releases<span class="hljs-regexp">/23.05.4/</span>packages<span class="hljs-regexp">/aarch64_cortex-a53/</span>routing<br>src<span class="hljs-regexp">/gz handsomemod_telephony https:/</span><span class="hljs-regexp">/downloads.immortalwrt.org/</span>releases<span class="hljs-regexp">/23.05.4/</span>packages<span class="hljs-regexp">/aarch64_cortex-a53/</span>telephony<br></code></pre></td></tr></table></figure><p>现在就可以正常更新了。</p><h3 id="修复基带固件"><a href="#修复基带固件" class="headerlink" title="修复基带固件"></a>修复基带固件</h3><p>无论是刷 OpenWrt 还是 Debian，都需要修复基带固件，否则无法正常使用 SIM 卡的网络。</p><p><img src="https://s2.loli.net/2024/12/02/Oy9BSh3wHJlRx6k.png" alt="图 23">  </p><p>将之前 9008 备份<code>modem</code>分区备份出来的<code>NON-HLOS.bin</code>改名为<code>NON-HLOS.img</code>，然后使用<code>DiskGenius</code>打开，将<code>image</code>文件夹复制出来，下图是<code>image</code>文件夹里的内容。</p><p><img src="https://s2.loli.net/2024/11/28/ilvS3trxfGY85zH.png" alt="图 10">  </p><p>我们需要将<code>image</code>里的所有文件复制到 OpenWrt 的<code>/lib/firmware</code>或者 Debian 的<code>/usr/lib/firmware</code>目录下，然后重启棒子。</p><blockquote><p>Tips：如果你是用命令行来使用 ssh，那么你可以使用<code>scp</code>命令来复制文件。</p><p><strong>OpenWrt</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -r /path/to/image/* root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">1</span><span class="hljs-symbol">:/lib/firmware</span><br></code></pre></td></tr></table></figure><p><strong>Debian</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -r /path/to/image/* root<span class="hljs-variable">@10</span>.<span class="hljs-number">42.0</span>.<span class="hljs-number">1</span><span class="hljs-symbol">:/usr/lib/firmware</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="短信转发"><a href="#短信转发" class="headerlink" title="短信转发"></a>短信转发</h2><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q：为什么我访问<code>http://192.168.100.1/usbdebug.html</code>后，用<code>adb devices</code>命令无法识别到设备？</p><p>A：请使用<code>设备管理器</code>检查你的设备驱动是否正常（即设备图标旁边是否有个感叹号），如果有感叹号，请把设备卸载（勾选删除驱动），然后重新尝试进入 adb 模式。</p><p>Q：为什么我进入了 9008 模式，但是在 QPT 里识别不到设备？</p><p>A：还是驱动问题，请确保你安装了 9008 驱动并且重启了电脑，然后再次让棒子进入 9008 模式就可以成功识别。</p><p>Q：为什么我的<code>OpenWrt/Debian</code>系统上不了网？</p><p>A：请先确保你的棒子连接到了可以访问互联网的网络：WiFi、GSM 等。如果还是不能联网，请检查系统的 DNS 设置，使用<code>vim</code>或者<code>nano</code>编辑<code>/etc/resolv.conf</code>文件，添加<code>nameserver 8.8.8.8</code>，保存并退出。</p>]]></content>
    
    
    <categories>
      
      <category>随身WiFi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随身WiFi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unity-shader-log-01</title>
    <link href="/2024/10/09/unity-shader-log-01/"/>
    <url>/2024/10/09/unity-shader-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unity-input-log-02</title>
    <link href="/2024/10/09/unity-input-log-02/"/>
    <url>/2024/10/09/unity-input-log-02/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式学习日志 01</title>
    <link href="/2024/10/09/design-pattern-log-01/"/>
    <url>/2024/10/09/design-pattern-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity UI开发日志 02</title>
    <link href="/2024/10/09/unity-ui-log-02/"/>
    <url>/2024/10/09/unity-ui-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="UI-Builder"><a href="#UI-Builder" class="headerlink" title="UI Builder"></a>UI Builder</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Input开发日志 01</title>
    <link href="/2024/10/01/unity-input-log-01/"/>
    <url>/2024/10/01/unity-input-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Input-System-和-Input-Manager"><a href="#Input-System-和-Input-Manager" class="headerlink" title="Input System 和 Input Manager"></a>Input System 和 Input Manager</h2><p><code>Input System</code>是新一代的输入方案，相比于<code>Input Manager</code>，它更加灵活与强大，但是因为坑很多所以大厂还是在用<code>Input Manager</code>。</p><p>不过<code>Input System</code>确实是处理了很多独立开发者在进行输入控制时可能遇到的痛点，所以还是值得推荐的，至少它不像<code>Addressable</code>那样只有坑，没有好处。</p><h2 id="安装Input-System"><a href="#安装Input-System" class="headerlink" title="安装Input System"></a>安装Input System</h2><p>在Unity引擎中选中工具栏中的<code>Window</code> -&gt; <code>Package Manager</code>，然后在搜索栏中输入<code>Input System</code>并安装。</p><p>然后我们需要在<code>Project Settings</code>中激活<code>Input System</code>，在<code>Project Settings</code>中选择<code>Player</code> -&gt; <code>Other Settings</code> -&gt; <code>Active Input Handling</code> -&gt; <code>Input System Package (New)</code>。</p><h2 id="使用Input-System"><a href="#使用Input-System" class="headerlink" title="使用Input System"></a>使用Input System</h2><p>要使用<code>Input System</code>，我们需要先创建一个<code>Input Action</code>。</p><p>在这个<code>Input Action</code>里创建一个<code>Action Map</code>，然后在这个<code>Action Map</code>里创建<code>Action</code>，每个<code>Action</code>代表一个输入设备上的一个输入事件。</p><p>在Inspector中我们让<code>Input Action</code>创建C#类，这样我们就可以在代码中使用这个<code>Input Action</code>。</p><p>假设我们有一个叫作<code>PlayerInputActions</code>的<code>Input Action</code>，我们可以在代码中这样使用它：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">PlayerInputActions inputActions = <span class="hljs-keyword">new</span> PlayerInputActions();<br><span class="hljs-keyword">var</span> variable = inputActions.Player.Move.ReadValue&lt;Vector2&gt;();<br></code></pre></td></tr></table></figure><p>上面的代码中<code>PlayerInputActions</code>是C#类名，<code>Player</code>是<code>Action Map</code>名，<code>Move</code>是<code>Action</code>名，我们可以在<code>Input Action</code>的Inspector中设置每个Action的<code>Control Type</code>以控制它的输入使用的类型，然后用<code>ReadValue&lt;type&gt;()</code>方法来读取输入事件的值。</p><h2 id="Player-Input-EventSystem"><a href="#Player-Input-EventSystem" class="headerlink" title="Player Input + EventSystem"></a>Player Input + EventSystem</h2><p>我们可以通过<code>Player Input</code>组件来绑定<code>Action</code>，然后通过<code>EventSystem</code>来处理输入事件，可以实现更加灵活的输入处理。但需要注意的是<code>EventSystem</code>在<code>Input System</code>与<code>Input Manager</code>的不同，比如我们需要先<strong>Disable</strong>后再<strong>Enable</strong><code>EventSystem</code>的实例，才能手动更改<code>EventSystem</code>的<code>currentSelectedGameObject</code>，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">EventSystem eventSystem = EventSystem.current;<br>eventSystem.enabled = <span class="hljs-literal">false</span>;<br>eventSystem.currentSelectedGameObject = <span class="hljs-literal">null</span>;<br>eventSystem.currentSelectedGameObject = targetGameObject;<br>eventSystem.enabled = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>否则会遇上将<code>currentSelectedGameObject</code>改为某个Button时会调用其<code>OnClick</code>方法等问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Input System</code>是Unity引擎中新的输入方案，相比于<code>Input Manager</code>，它更加灵活与强大，但它也存在很多问题，如果不是必要，还是不要用它。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>assembly-log-01</title>
    <link href="/2024/09/28/assembly-log-01/"/>
    <url>/2024/09/28/assembly-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习日志 01</title>
    <link href="/2024/09/28/os-log-01/"/>
    <url>/2024/09/28/os-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>鉴于 Linux 作者 Linus Torvalds 最近的一些言论，我觉得自己应该多关注一下操作系统的发展，因此打算学习一下操作系统的一些知识。<br>操作系统学习日志是我学习操作系统的笔记，主要记录一下自己学习过程中的心得体会。<br>本系列博客主要参考了《ARM64 体系结构编程与实践》一书，感谢作者的无私奉献。</p><h2 id="ARM-架构"><a href="#ARM-架构" class="headerlink" title="ARM 架构"></a>ARM 架构</h2><p>ARM 架构从 v1 到 v9 出了很多版本，ARM 总体的体系结构又根据不同应用场景划分为不同的架构，如 ARM Cortex-A、ARM Cortex-M、ARM Cortex-R，它们分别面向性能密集型系统的应用、实时应用和嵌入式应用。</p><h2 id="ARM-v8-体系结构基础知识"><a href="#ARM-v8-体系结构基础知识" class="headerlink" title="ARM v8 体系结构基础知识"></a>ARM v8 体系结构基础知识</h2><p>ARMv8 是 ARM 公司发布的第一代支持 64 位处理器的指令集和体系结构。它还兼容上一代 ARM 指令集，因此它也提供了运行 32 位和 64 位应用程序的环境。</p><p>ARMv8 体系结构一共有 8 个小版本，从 ARMv8.0 到 ARMv8.7，每个小版本都对体系结构进行小幅度升级和优化，增加了一些新的特性。</p><h2 id="采用-ARMv8-架构的常见处理器内核"><a href="#采用-ARMv8-架构的常见处理器内核" class="headerlink" title="采用 ARMv8 架构的常见处理器内核"></a>采用 ARMv8 架构的常见处理器内核</h2><ul><li><p>Cortex-A53</p></li><li><p>Cortex-A72</p></li></ul><h2 id="ARMv8-体系结构中的基本概念"><a href="#ARMv8-体系结构中的基本概念" class="headerlink" title="ARMv8 体系结构中的基本概念"></a>ARMv8 体系结构中的基本概念</h2><ul><li><p>处理机（Processing Element, PE）：在 ARM 公司的官方技术手册中提到的一个概念，把处理器处理事务的过程抽象位处理机。</p></li><li><p>执行状态（execution state）：处理器运行时的环境，包括寄存器的位宽、支持的指令集、异常模型、内存管理以及编程模型等。ARMv8 体系结构定义了两个执行状态。</p><blockquote><ul><li>AArch64：64 位的执行状态。<blockquote><ul><li>提供 31 个 64 位的通用寄存器。</li><li>提供 64 位的程序计数（Program Counter, PC）指针寄存器、栈指针（Stack Pointer, SP）寄存器以及异常链接寄存器（Exception Link Register, ELR）。</li><li>提供 A64 指令集。</li><li>定义 ARMv8 异常模型，支持 EL0~EL3 这 4 个异常级别。</li><li>提供 64 位的内存模型。</li><li>定义一组处理器状态（PSTATE）用来保存 PE 的状态。</li></ul></blockquote></li></ul></blockquote></li></ul><blockquote><ul><li>AArch32：32 位的执行状态。<blockquote><ul><li>提供 13 个 32 位的通用寄存器，再加上 PC 指针寄存器、SP 寄存器、链接寄存器 (Link Register,LR)。</li><li>支持两套指令集，分别是 A32 和 T32(Thumb 指令集）指令集。</li><li>支持 ARMv7-A 异常模型，基于 PE 模式并映射到 ARMv8 的异常模型中。</li><li>提供 32 位的虚拟内存访问机制。</li><li>定义一组 PSTATE 用来保存 PE 的状态。</li></ul></blockquote></li></ul></blockquote><ul><li><p>ARMv8 指令集：ARMv8 体系结构根据不同的执行状态提供不同的指令集的支持。</p></li><li><ul><li>A64 指令集：运行在 AArch64 状态下，提供 64 位指令集支持。</li></ul></li><li><ul><li>A32 指令集：运行在 AArch32 状态下，提供 32 位指令集支持。</li></ul></li><li><ul><li>T32 指令集：运行在 AArch32 状态下，提供 16 位和 32 位指令集支持。</li></ul></li><li><p>系统寄存器命名：在 AArch64 状态下，很多系统寄存器会根据不同的异常等级提供不同的变种寄存器。系统寄存器的使用方法如下。</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;register_name&gt;</span><span class="hljs-attribute">_Elx</span> //最后一个字母 x 可以表示 <span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如 SP_EL0 表示在 EL0 下的 SP 寄存器。</p><h2 id="A64-指令集"><a href="#A64-指令集" class="headerlink" title="A64 指令集"></a>A64 指令集</h2><p>指令集是处理器体系结构设计的重点之一。ARM 公司定义与实现的指令集一直在变化和发展中。ARMv8 体系结构最大的改变是增加了一个新的 64 位的指令集，这是早前 ARM 指令集的有益补充和增强。它可以处理 64 位宽的寄存器和数据并且使用 64 位的指针来访问内存。这个新的指令集称为 A64 指令集，运行在 AArch64 状态下。ARMv8 兼容旧的 32 位指令集——A32 指令集，它运行在 AArch32 状态下。</p><p>A64 指令集和 A32 指令集是不兼容的，它们是两套完全不一样的指令集，它们的指令编码是不一样的。需要注意的是，A64 指令集的指令宽度是 32 位，而不是 64 位。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇先大致介绍一下 ARMv8 体系结构下的基本概念，详细的细节可以从参考书籍《ARM64 体系结构编程与实践》的第一章中学习，下一篇记录 BenOS 在 qemu 虚拟机上的运行。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#高级技巧 03</title>
    <link href="/2024/09/28/csharp-trick-03/"/>
    <url>/2024/09/28/csharp-trick-03/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是C# 3.0引入的新特性，它允许我们在代码中定义匿名函数，并将其赋值给变量。</p><p>Lambda表达式的语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(input parameters) =&gt; expression<br></code></pre></td></tr></table></figure><ol><li><code>input parameters</code>：输入参数，可以是0个或多个。</li><li><code>=&gt;</code>：箭头，表示将输入参数映射到表达式。</li><li><code>expression</code>：表达式，可以是任意有效的C#代码。</li></ol><p>举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y;<br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// result = 3</span><br></code></pre></td></tr></table></figure><p>上面的代码定义了一个匿名函数，它接受两个int型参数，并返回它们的和。然后将这个匿名函数赋值给一个变量<code>add</code>，并调用它，得到结果3。</p><p>Lambda表达式的好处是可以简化代码，使代码更加简洁，更易于阅读。而且它提供了一种创建匿名函数的便捷方式。不需要为函数命名时，可以直接使用Lambda表达式。</p><h2 id="Lambda表达式类型推断"><a href="#Lambda表达式类型推断" class="headerlink" title="Lambda表达式类型推断"></a>Lambda表达式类型推断</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络学习日志 01</title>
    <link href="/2024/09/28/network-log-01/"/>
    <url>/2024/09/28/network-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>简单来说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。两台计算机之间必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现通信。</p><h3 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h3><p>分组交换协议（Packet Switching Protocol）是指将大数据分割成一个个叫作包（Packet）的较小单位进行传输的方法。</p><p>计算机通信会在每一个分组中附加上源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分称为“报文首部”。</p><p>一个较大的数据被分为多个分组时，为了标明是原始数据中的哪一部分，就有必要将分组的序号写入包中。接收端会根据这个序号，再将每个分组按照序号重新装配为原始数据。</p><p>通信协议中，通常会规定报文首部应该写入哪些信息、应该如何处理这些信息。相互通信的每一台计算机则根据协议构造报文首部、读取首部内容等。为了双方能正确通信，分组的发送方和接收方有必要对报文首部和内容保持一致的定义和解释。</p><h2 id="协议的标准化"><a href="#协议的标准化" class="headerlink" title="协议的标准化"></a>协议的标准化</h2><p>ISO（International Organization for Standards，国际标准化组织）制定了一个国际标准OSI（Open Systems Interconnection，开放式通信系统互联参考模型），对通信系统进行了标准化。</p><p>但是TCP&#x2F;IP并非ISO所制定的某种国际标准。而是由IETF（Internet Engineering Force）所建议的、致力于推进其标准化作业的一种协议。</p><p>OSI所定义的协议虽然未被普及，但在它设计之初作为其知道方针的OSI参考模型却常被用于网络协议的制定中。</p><h2 id="协议分层与OSI参考模型"><a href="#协议分层与OSI参考模型" class="headerlink" title="协议分层与OSI参考模型"></a>协议分层与OSI参考模型</h2><h3 id="协议的分层"><a href="#协议的分层" class="headerlink" title="协议的分层"></a>协议的分层</h3><p>OSI参考模型将通信协议中必要的功能分成了7层，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务。上下层之间进行交互时所遵循的约定叫作“接口”，同一层之间的交互所遵循的约定叫作“协议”。</p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="OSI模型各层功能概述"><a href="#OSI模型各层功能概述" class="headerlink" title="OSI模型各层功能概述"></a>OSI模型各层功能概述</h3><table><thead><tr><th>分层名称</th><th>功能</th></tr></thead><tbody><tr><td>应用层</td><td>针对特定应用的协议。</td></tr><tr><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换。</td></tr><tr><td>会话层</td><td>通信管理。负责建立和断开通信连接（数据流动的逻辑通路）。管理传输层以下的分层。</td></tr><tr><td>传输层</td><td>管理两个节点之间的数据传输。负责可靠传输（确保数据被可靠地传送到目标地址）。</td></tr><tr><td>网络层</td><td>地址管理与路由选择。</td></tr><tr><td>数据链路层</td><td>互连设备之间传送和识别数据帧。</td></tr><tr><td>物理层</td><td>以“0”、“1”代表电压的高低、灯光的闪灭。界定连接器和网线的规格。</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天的学习内容主要是了解计算机网络的一些基本概念和协议。下一篇开始根据例子了解OSI模型各层的功能与原理。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向工程学习日志 02</title>
    <link href="/2024/09/18/reverse-log-02/"/>
    <url>/2024/09/18/reverse-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="认识指令集架构"><a href="#认识指令集架构" class="headerlink" title="认识指令集架构"></a>认识指令集架构</h2><p>在x86的指令集架构(ISA)中，各opcode（汇编指令对应的机器码）的长度不尽相同，出于兼容性考虑，当年的16位8086 CPU的指令甚至被保留到了现在的CPU中，而在ARM架构中，opcode的长度都为4个字节，也就是32位，但ARM架构的设计师们很快发现这种模式并不合适，因为实际应用中绝大多数CPU指令都用不满那4个字节，因此他们又推出了一种把每条指令封装在2个字节的“Thumb”模式中，不过因为Thumb模式并不能封装所有的指令，因此一个程序里可以同时存在两种模式的指令。</p><p>在ARM v7平台上出现了Thumb-2指令集，Thumb-2的指令基本都可封装到2个字节中，2个字节封装不下的指令则由4个字节封装。Thumb-2实际上是一种充分利用处理器性能，足以与ARM模式媲美的独立的运行模式，而不是ARM指令集和Thumb指令集的复合体。</p><p>在后来64位的ARM处理器出现，ARM64架构采用4位字节封装CPU指令，不再支持Thumb模式。所以ARM指令集实际分为三类：</p><ol><li>ARM模式指令集</li><li>Thumb模式指令集(包括Thumb-2)</li><li>ARM64模式指令集</li></ol><p>本系列博客，我们主要学习x86和ARM指令集。</p><h2 id="最简函数（第2章）"><a href="#最简函数（第2章）" class="headerlink" title="最简函数（第2章）"></a>最简函数（第2章）</h2><p>返回预定常量的函数，已经算得上是最简单的函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">f:<br>    mov eax, 123<br>    ret<br></code></pre></td></tr></table></figure><p>在x86上，这个函数仅由两条指令组成，一条是mov指令，用来将常量123加载到EAX寄存器中，另一条是ret指令，它会将EAX的值当作返回值返回给调用者函数，调用者函数会从EAX寄存器中取回返回值。</p><h3 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">f PROC<br>    MOV r0,#0x7b ; 123<br>    BC lr<br>    ENDP<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次网络问题排查</title>
    <link href="/2024/09/07/network-fix/"/>
    <url>/2024/09/07/network-fix/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Windows热点无法被连接，显示没有IP地址被分配。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><ol><li><p>打开网络适配器属性，查看IPv4地址是否被分配。</p></li><li><p>打开控制面板，查看网络和Internet连接是否正常。</p></li><li><p>尝试重新启动计算机。</p></li><li><p>尝试更换热点名称。</p></li><li><p>尝试更换热点密码。</p></li><li><p>尝试重新安装驱动程序。</p></li><li><p>使用命令ipconfig &#x2F;all查看网络设备状态与配置。</p></li><li><p>使用命令ipconfig &#x2F;release和ipconfig &#x2F;renew释放和分配IP地址。</p></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>经排查发现DHCP未正确运行，导致Windows无法自动分配IP地址。</p><p>尝试以下方案：</p><ol><li><p>打开网络适配器属性，选择“属性”选项卡，点击“Internet协议版本4”选项，点击“属性”按钮。</p></li><li><p>手动分配IP地址，将最后一段IP改为“251”后点击应用。</p></li><li><p>重启热点。</p></li></ol><p>经过以上步骤，Windows热点可以正常连接。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>Clash TUN模式未正确关闭，导致DHCP未释放IP地址，暂未找到恢复DHCP的方法，只能通过手动分配IP地址解决。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓SWAP探索 01</title>
    <link href="/2024/04/14/android-swap-log-01/"/>
    <url>/2024/04/14/android-swap-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是SWAP？"><a href="#什么是SWAP？" class="headerlink" title="什么是SWAP？"></a>什么是SWAP？</h2><p>SWAP是Linux下的一个磁盘分区，Linux内核可将其当作内存进行使用，以此来在不增加物理内存的情况下获得更大的内存。</p><h2 id="SWAP的种类"><a href="#SWAP的种类" class="headerlink" title="SWAP的种类"></a>SWAP的种类</h2><h3 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h3><p>SWAP将磁盘上的一块指定大小的连续区域划为SWAP分区，在内存用量到达指定阈值时会将多出的内存内容写入到SWAP分区中，将SWAP分区作为内存进行使用，通过占用一部分磁盘增加设备的可用内存。</p><h3 id="ZRAM"><a href="#ZRAM" class="headerlink" title="ZRAM"></a>ZRAM</h3><p>ZRAM是一种SWAP实现，它采用虚拟分区在内存上模拟出一块系统分区，它将内存中暂时不被用到的内容压缩起来，在需要的时候解压还原，以此变相增加设备的可用内存。</p><h2 id="安卓上调整SWAP"><a href="#安卓上调整SWAP" class="headerlink" title="安卓上调整SWAP"></a>安卓上调整SWAP</h2><p>在安装了Magisk或KernelSU的前提下，可以使用<strong>scene</strong>的swap附加模块方便快捷地调整安卓系统的swap分区及其相关参数。</p><h2 id="有关ZRAM的调整"><a href="#有关ZRAM的调整" class="headerlink" title="有关ZRAM的调整"></a>有关ZRAM的调整</h2><p>首先，也是最重要的，<strong>不要开ZRAM Writeback</strong>，没有必要。ZRAM Writeback是ZRAM的一个可选特性，它会将压缩后的内存内容写入磁盘中的ZRAM Writeback分区，在需要的时候会从磁盘读取出来后解压，这个过程涉及磁盘IO，与SWAP分区一样会减少磁盘的寿命，但是因为进行了磁盘IO，ZRAM的运行性能反而会下降。ZRAM Writeback也是手机厂商使用的内存融合、内存扩展所采用的技术，建议有条件的用户使用普通的ZRAM，不要使用ZRAM Writeback。</p><p>然后，就是ZRAM算法的选择，ZRAM算法决定了ZRAM的CPU占用以及ZRAM可压缩的内存内容大小（或者说ZRAM增加的等效内存大小），安卓平台的ZRAM有四种算法可选，分别是lzo-rle、lzo、lz4、zstd。安卓系统默认为lzo-rle，也是Linux上的ZRAM默认使用的算法，这是一种在压缩率、压缩速度以及CPU占用上取得了平衡的算法，lzo算法与其差不多，但是在一些极端情况下不如lzo-rle。lz4算法的压缩速度最快，CPU占用最低，但是压缩率最低。zstd算法的压缩率最高，CPU占用最高，压缩速度与lzo和lzo-rle差不多。所以建议CPU较好的设备使用zstd算法以增加更多的可用内存，CPU一般的设备使用lzo-rle，CPU较差但想使用ZRAM的设备使用lz4算法。</p><p>最后，就是ZRAM的大小问题，可以根据自己需要增加的内存大小以及ZRAM算法的压缩率计算需要分配多少的ZRAM，比如lzo-rle算法的压缩率约为20%~30%，设备的物理内存有8 GB，那么所有内存内容压缩后的大小为1.6 GB ~ 2.4 GB，即若将ZRAM设为8 GB时，可以为设备增加5.6 GB ~ 6.4 GB的等效内存，相当于此时设备的可用内存大小为13.6 GB ~ 14.4 GB。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>powershell-log-01</title>
    <link href="/2024/04/14/powershell-log-01/"/>
    <url>/2024/04/14/powershell-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓Root学习日志 02</title>
    <link href="/2024/04/07/android-rooting-log-02/"/>
    <url>/2024/04/07/android-rooting-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="编写Magisk模块"><a href="#编写Magisk模块" class="headerlink" title="编写Magisk模块"></a>编写Magisk模块</h2><p>如果你刷入过Magisk模块，你就会知道，Magisk模块只是一个普通的zip文件，那么怎么制作这么一个zip文件呢？</p><h3 id="module-prop"><a href="#module-prop" class="headerlink" title="module.prop"></a>module.prop</h3><p>一个模块最核心的文件就是<code>module.prop</code>这个文件，没有这个文件的存在，Magisk就无法将这个zip文件识别成Magisk模块并刷入，那么怎么写一个module.prop呢？</p><p>一个module.prop一般包含以下的属性：</p><ul><li>id：模块的ID，字符串。不可与其他模块一致</li><li>name：模块的名称，字符串，刷入后会显示在管理器中</li><li>version：模块的版本名称，字符串，刷入后会显示在管理器中</li><li>versionCode：模块的版本代号，整数，表示模块内部的版本号</li><li>author：模块的作者，字符串，刷入后会显示在管理器中</li><li>description：模块的描述，字符串，刷入后会显示在管理器中</li></ul><p>最基本的属性就以上6个，将其填写进module.prop再将module.prop打包成任意名称的zip文件，就相当于做好一个模块了，以下是一个module.prop的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span>=example<br>name=ExampleModule<br>version=v1<br>versionCode=1<br>author=Blackwood416<br>description=This is a simple example module<br></code></pre></td></tr></table></figure><p>请注意，module.prop需要以bash语法编写，即属性通过等号赋值，且等号两边不能有空格。</p><h3 id="通过Overlay更改系统文件"><a href="#通过Overlay更改系统文件" class="headerlink" title="通过Overlay更改系统文件"></a>通过Overlay更改系统文件</h3><p>Magisk提供了一种叫作Overlay的方式来在不更改真实系统文件的情况下覆盖系统文件的内容。</p><p>对于<code>/system/build.prop</code>，我们可以通过在Magisk模块中编写<code>system.prop</code>来覆盖它里面的系统属性。</p><p>比如，要在设备上开启屏幕广色域支持，我们可以在system.prop中加入下面这行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ro.surface_flinger.has_wide_color_display=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再将其与module.prop打包成zip重新刷入，重启后我们就可以发现设备能被检测出支持广色域。</p><p>再比如，我们想把已安装的某个应用转为系统应用，这时我们可以在Magisk模块的目录下面新建一个叫作<code>system</code>的文件夹，再在里面新建你想放到的系统应用文件夹，<code>app</code>或<code>priv-app</code>，然后到<code>/data/app</code>下找到该应用的目录，将目录中的<strong>lib</strong>、<strong>oat</strong>和<strong>base.apk</strong>复制到<code>app</code>或<code>priv-app</code>中，最后将<code>system</code>文件夹与<code>system.prop</code>和<code>module.prop</code>一起打包成zip，刷入后即可将目标应用转为系统应用，此时模块的目录结构如下：</p><p>|- module.prop<br>|- system.prop<br>|- system&#x2F;<br>|- |- app&#x2F;<br>|- |- |- lib&#x2F;<br>|- |- |- oat&#x2F;<br>|- |- |- base.apk</p><h3 id="customize-sh"><a href="#customize-sh" class="headerlink" title="customize.sh"></a>customize.sh</h3><p>这个脚本是用来控制模块安装时的行为的，比如我们可以写一个脚本来检查设备是否符合某些条件，如果不符合则阻止安装。</p><h3 id="uninstall-sh"><a href="#uninstall-sh" class="headerlink" title="uninstall.sh"></a>uninstall.sh</h3><p>该脚本会在Magisk模块被卸载时被Magisk调用，我们可以在其中写一些逻辑来控制卸载模块时的行为。</p><h3 id="service-sh"><a href="#service-sh" class="headerlink" title="service.sh"></a>service.sh</h3><p>我们可以在这个脚本里用sh语法写一个循环来持续运行一些逻辑，比如我们可以写一个定时任务来每隔一段时间执行一些操作，或者我们可以写一个后台服务来监听系统事件并做出相应的反应，相当于注册了一个系统服务。</p><h3 id="post-fs-data-sh"><a href="#post-fs-data-sh" class="headerlink" title="post-fs-data.sh"></a>post-fs-data.sh</h3><p>该脚本会在系统启动完成后被Magisk调用，我们可以在其中写一些逻辑来控制系统启动后的行为。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透学习 01</title>
    <link href="/2024/04/07/penetration-log-01/"/>
    <url>/2024/04/07/penetration-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是渗透？"><a href="#什么是渗透？" class="headerlink" title="什么是渗透？"></a>什么是渗透？</h2>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库学习日志 01</title>
    <link href="/2024/04/07/database-log-01/"/>
    <url>/2024/04/07/database-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blazor开发日志 01</title>
    <link href="/2024/04/06/blazor-log-01/"/>
    <url>/2024/04/06/blazor-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Blazor是什么？"><a href="#Blazor是什么？" class="headerlink" title="Blazor是什么？"></a>Blazor是什么？</h2><p>Blazor是微软官方开发维护的一个web应用框架，能使用C#进行web开发，并且得益于.Net，部署Blazor应用非常的简单，当然除了C#，Blazor还能使用webassembly来嵌入其他编译型语言的代码，Blazor兼顾客户端的可交互性与服务器端渲染的功能，这使得它在处理大量动态UI时有明显的性能优势，总的来说Blazor是一个兼具性能与开发效率的框架，而且不是MAUI那种半成品，十分建议想搞web app的Csharper来使用。</p><h2 id="创建一个Blazor项目"><a href="#创建一个Blazor项目" class="headerlink" title="创建一个Blazor项目"></a>创建一个Blazor项目</h2><p>在VS里我们可以很容易的创建一个Blazor项目，在创建项目的模板里找到Blazor Web App，然后填项目名和解决方案的名称就可以了。</p><p>这里我们来说一下Linux命令行下要怎么使用<code>dotnet</code>来创建一个Blazor项目。</p><p>先来查看一下本地是否已经安装了.Net SDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet --list-sdks<br><span class="hljs-comment"># 应该显示出如下形式的信息：</span><br><span class="hljs-comment"># 8.0.202 [/usr/share/dotnet/sdk]</span><br></code></pre></td></tr></table></figure><p>创建Blazor项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet new blazor -n NewBlazorApp<br></code></pre></td></tr></table></figure><h2 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h2><p>Blazor模板自带了一些东西，我们可以运行起来看看，在VS里点击绿色的 ▶ 即可开始运行，会自动开启一个终端并拉起默认浏览器。</p><p>如果在Linux里，首先要确保你有安装Asp.Net的runtime，运行以下命令查看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet --list-runtimes<br><span class="hljs-comment"># 其中一行需要显示为如下形式：</span><br><span class="hljs-comment"># Microsoft.AspNetCore.App 8.0.3 [/usr/share/donet/shared/Microsoft.AspNetCore.App]</span><br></code></pre></td></tr></table></figure><p>如果没有这个runtime，可以去官网下载压缩包来安装，或者用包管理器安装，使用Arch Linux的话，可以在archlinuxcn源中找到<code>aspnet-runtime-bin</code>这个包，用<code>pacman</code>安装即可。</p><p>安装完成后我们<code>cd</code>进Blazor项目的文件夹，然后输入<code>dotnet watch</code>即可运行该Blazor项目，然后看输出会有一行<code>Now listening on: http://localhost:5188</code>，这表示我们可以通过这个网址来访问我们运行的Blazor项目，当然如果你使用了图形界面，并且有安装浏览器并将其设为默认浏览器，那么运行<code>dotnet watch</code>可能会帮你自动拉起浏览器并跳转到该网址。</p><h2 id="Blazor项目结构"><a href="#Blazor项目结构" class="headerlink" title="Blazor项目结构"></a>Blazor项目结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">NewBlazorApp<br>├── ClientApp<br>│   ├── Pages<br>│   │   ├── Index<span class="hljs-selector-class">.razor</span><br>│   │   └── _Host<span class="hljs-selector-class">.cshtml</span><br>│   ├── Program<span class="hljs-selector-class">.cs</span><br>│   ├── Startup<span class="hljs-selector-class">.cs</span><br>│   └── wwwroot<br>│       ├── css<br>│       ├── <span class="hljs-selector-tag">img</span><br>│       ├── js<br>│       └── lib<br>├── NewBlazorApp<span class="hljs-selector-class">.csproj</span><br>└── Properties<br>    └── launchSettings.json<br></code></pre></td></tr></table></figure><ol><li><code>ClientApp</code>：Blazor的客户端代码，包括Razor组件、CSS、JS等。</li><li><code>Program.cs</code>：Blazor的入口点，负责配置Blazor应用的服务并启动。</li><li><code>Startup.cs</code>：Blazor的启动配置，包括路由配置、身份验证配置等。</li><li><code>wwwroot</code>：Blazor的静态资源目录，包括CSS、JS、图片等。</li><li><code>Properties</code>：Blazor的配置文件目录，包括<code>launchSettings.json</code>文件。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Blazor是一个非常优秀的web应用框架，它能让我们用C#来开发web应用，并且能在客户端和服务器端都能运行，而且性能也非常好，十分适合处理大量动态UI的场景。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blazor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#高级技巧 02</title>
    <link href="/2024/03/11/csharp-trick-02/"/>
    <url>/2024/03/11/csharp-trick-02/</url>
    
    <content type="html"><![CDATA[<h2 id="Switch表达式"><a href="#Switch表达式" class="headerlink" title="Switch表达式"></a>Switch表达式</h2><p>C#的表达式那可谓一绝，今天就来讲讲switch表达式。</p><p>学过C语言的人可能觉得switch的用处比较少，用的没if…else那么频繁，但是在C#里有了switch表达式后，switch可以说是又方便，可读性又高，不考虑性能的话能在很多情况下代替if…else。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>var result &#x3D; expression switch<br>{<br>    case pattern1 when condition1: result1,<br>    case pattern2 when condition2: result2,<br>   …<br>    case patternN when conditionN: resultN,<br>    _ &#x3D;&gt; defaultResult<br>};</p><ul><li>expression：表达式，可以是任何类型，switch表达式会根据表达式的值来决定执行哪个case。</li><li>pattern：模式，可以是任何类型，可以是一个值，也可以是一个范围。</li><li>condition：条件，可以是一个表达式，只有当表达式为true时才执行对应的case。</li><li>result：结果，可以是任何类型，当表达式的值与pattern匹配时，就会返回对应的result。</li><li>defaultResult：默认结果，当表达式的值与所有pattern都不匹配时，就会返回默认结果。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>switch表达式必须包含至少一个case，否则会报错。</li><li>case的顺序很重要，如果有多个case匹配，则只会执行第一个匹配的case。</li></ul><h2 id="常用写法"><a href="#常用写法" class="headerlink" title="常用写法"></a>常用写法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetNumber</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> input <span class="hljs-keyword">switch</span><br>    &#123;<br>        <span class="hljs-string">&quot;one&quot;</span> =&gt; <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;two&quot;</span> =&gt; <span class="hljs-number">2</span>,<br>        <span class="hljs-string">&quot;three&quot;</span> =&gt; <span class="hljs-number">3</span>,<br>        _ =&gt; <span class="hljs-number">0</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch表达式最常见的用法就是用于返回特定值的方法。</p><p>也可以简化成Lambda表达式的形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetNumber</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input</span>)</span> =&gt; input <span class="hljs-keyword">switch</span><br>&#123;<br>    <span class="hljs-string">&quot;one&quot;</span> =&gt; <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;two&quot;</span> =&gt; <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;three&quot;</span> =&gt; <span class="hljs-number">3</span>,<br>    _ =&gt; <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的写法非常简洁。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言高级技巧 01</title>
    <link href="/2024/02/22/c-trick-01/"/>
    <url>/2024/02/22/c-trick-01/</url>
    
    <content type="html"><![CDATA[<h2 id="写文目的"><a href="#写文目的" class="headerlink" title="写文目的"></a>写文目的</h2><p>本系列博客主要目的在于记录C语言的一些高级使用技巧，以提高使用C语言时的开发效率。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#高级技巧 01</title>
    <link href="/2024/02/22/csharp-trick-01/"/>
    <url>/2024/02/22/csharp-trick-01/</url>
    
    <content type="html"><![CDATA[<h2 id="写文目的"><a href="#写文目的" class="headerlink" title="写文目的"></a>写文目的</h2><p>众所周知C#是语法糖最多的一门编程语言，而我们肯定是不能记住所有语法糖的，所以我就想新开一个系列的博客来记录一下我学过的语法糖。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C#的字符串花样太多了。我们首先讲点简单的。</p><p>从古至今，字符串处理对程序员来说都是个很掉头发的问题，更别说有的语言字符串适配本身就是依托答辩，我们今天就来讲讲C#中那些字符串相关的语法糖。</p><h3 id="字符串内插"><a href="#字符串内插" class="headerlink" title="字符串内插"></a>字符串内插</h3><p>字符串内插是C#中一个很有用的语法糖。我们可以用<code>$&#123;&#125;</code>来表示一个变量，然后在字符串中插入这个变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Tom&quot;</span>;<br><span class="hljs-built_in">string</span> message = <span class="hljs-string">$&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>;<br>Console.WriteLine(message); <span class="hljs-comment">// Output: Hello, Tom</span><br></code></pre></td></tr></table></figure><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串拼接也是一个很常用的语法糖。我们可以用<code>+</code>来拼接字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Tom&quot;</span>;<br><span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>Console.WriteLine(message); <span class="hljs-comment">// Output: Hello, Tom</span><br></code></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>字符串格式化也是一个很常用的语法糖。我们可以用<code>string.Format()</code>来格式化字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Tom&quot;</span>;<br><span class="hljs-built_in">string</span> message = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;Hello, &#123;0&#125;&quot;</span>, name);<br>Console.WriteLine(message); <span class="hljs-comment">// Output: Hello, Tom</span><br></code></pre></td></tr></table></figure><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>字符串切片也是一个很常用的语法糖。我们可以用<code>[start..end]</code>来切片字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Tom&quot;</span>;<br><span class="hljs-built_in">string</span> message = name[<span class="hljs-number">1.</span><span class="hljs-number">.3</span>];<br>Console.WriteLine(message); <span class="hljs-comment">// Output: o</span><br></code></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>原始字符串也是一个很有用的语法糖。我们可以用<code>@</code>来表示一个字符串是原始字符串，这样就可以在字符串中使用转义字符。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> message = <span class="hljs-string">@&quot;Hello, \nTom&quot;</span>;<br>Console.WriteLine(message); <span class="hljs-comment">// Output: Hello, \nTom</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习日志 02</title>
    <link href="/2024/02/22/csharp-log-02/"/>
    <url>/2024/02/22/csharp-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐数字信号学习日志 01</title>
    <link href="/2024/02/17/music-log-01/"/>
    <url>/2024/02/17/music-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="为啥学音乐数字信号处理？"><a href="#为啥学音乐数字信号处理？" class="headerlink" title="为啥学音乐数字信号处理？"></a>为啥学音乐数字信号处理？</h2><p>作为一个游戏开发者，开发一个游戏时总免不了添加音乐和音效，此时，了解音乐数字信号处理的知识，可以帮助我们更好的理解音乐的原理，从而更好的实现游戏音乐的效果。</p><h2 id="音乐的原理"><a href="#音乐的原理" class="headerlink" title="音乐的原理"></a>音乐的原理</h2><p>我们在<code>Octave</code>里输入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs octave">function sine()<br>    x = [0:44099]<br>    y = sin(2*pi*440/44100*x)<br>    for i = 1:5<br>        sound(y, 44100)<br>        pause(0.5)<br>    end<br>end<br></code></pre></td></tr></table></figure><p>运行这段代码，你会听到 5 声类似电话忙线的声音。其实这就是通过数字信号模拟出的声音。</p><p>我们都知道声音是由振动产生的，而振动是由正弦波和方波叠加而成的。正弦波是最基本的波形，它的频率越高，声音越响，而方波则是其中的一种。</p><p>上面这段代码生成了一个<code>440Hz</code>的正弦波，并播放出来，我们用 for 循环播放 5 次，每次播放的时间为<code>0.5s</code>。</p><p>我们更改一下代码，让其生成一张波形图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs octave">function sine()<br>    x = [0:44099]<br>    y = sin(2*pi*440/44100*x)<br>    samples_per_cycle = 44100 / 440;<br>    plot(x(1:samples_per_cycle), y(1:samples_per_cycle));<br>    grid on;<br>    xlabel(&#x27;Sample Index&#x27;);<br>    ylabel(&#x27;Amplitude&#x27;);<br>    title(&#x27;Sine Wave&#x27;);<br>    print -dpng &quot;sin.png&quot;;<br>end<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/21/VDtTmlYdxJjX3ru.png" alt="sin.png">  </p><p>这张图展示了这段音频单个周期的波形，我们可以看到它是一个标准的正弦波。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>澎湃OS折腾日志 02</title>
    <link href="/2024/02/17/hyperos-log-02/"/>
    <url>/2024/02/17/hyperos-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="低端机阉割"><a href="#低端机阉割" class="headerlink" title="低端机阉割"></a>低端机阉割</h2><p>MIUI不知道从什么时候开始，对中低端机加上了非常明显的阉割，轻一点的有狂暴引擎，AI大师引擎。重一点的有系统动画、系统应用（谷歌框架、小米互传、传送门、MIUI+、小米妙享、小米互联互通），甚至是一些系统功能（长截屏、最近应用界面的分屏小窗锁定应用等操作）。</p><p>某些阉割还是云控或者是同款机型的系统更新中移除的，这无疑引起了众多消费者的不满。</p><p>作为一个红米低端机的消费者，我肯定也是很不满的，但是我有时间，我有动手能力，我可以通过小米开放的途径（root和刷机）来拿回我应该有的体验，这才是我依旧选择小米的原因。</p><h2 id="恢复功能"><a href="#恢复功能" class="headerlink" title="恢复功能"></a>恢复功能</h2><p>其实对于大多数的功能，使用我们上一篇里提到的<strong>HyperCeiler</strong>就已经能够找回来了。那些找不回来的主要是没有安装并转成应用，接下来我们就来具体的讲一下一些阉割怎么解决。</p><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p>这可能是低端机最常阉割的一个功能了。但是它的恢复方法也是最简单的，那就是下载一个传送门，并将其转成系统应用，我们可以使用<strong>scene</strong>来操作。</p><p>只需在scene的应用管理中找到<strong>传送门</strong>然后选择<strong>转为系统应用</strong>，再选择存放位置为 <strong>&#x2F;system&#x2F;priv-app&#x2F;</strong> ，然后重启手机即可启用传送门。</p><p>HyperCeiler中也有一些对于传送门的增强选项，感兴趣的可以看一下。</p><h3 id="相册与相册编辑"><a href="#相册与相册编辑" class="headerlink" title="相册与相册编辑"></a>相册与相册编辑</h3><p>这个源于群友的酷安帖子。</p><p>想要恢复相册与相册编辑的功能，需要针对性的伪装机型，这时就轮到一个叫作<strong>Guise</strong>的LSP模块登场了。</p><p>我们先安装指定版本的小米相册与相册编辑。然后安装Guise，勾选作用域：系统框架、小米相册、相册编辑。再在Guise中为这俩个应用编辑伪装配置。群友说伪装成Note 11T Pro就行，以下是配置，可以保存为模板直接勾选这俩个应用，最后重启手机就好了。</p><h3 id="小爱大模型、小米妙享、小米互联互通与Hyper-Mind"><a href="#小爱大模型、小米妙享、小米互联互通与Hyper-Mind" class="headerlink" title="小爱大模型、小米妙享、小米互联互通与Hyper Mind"></a>小爱大模型、小米妙享、小米互联互通与Hyper Mind</h3><p>源于酷安的某篇帖子，里面详细如何偷渡小爱大模型和Hyper Mind，提升中低端机的手机助理与互联体验。</p><p>具体来说我们需要先安装几个低端机可能没有的应用，它们分别是</p><h3 id="MIUI-、小米互传、高斯模糊与系统动画"><a href="#MIUI-、小米互传、高斯模糊与系统动画" class="headerlink" title="MIUI+、小米互传、高斯模糊与系统动画"></a>MIUI+、小米互传、高斯模糊与系统动画</h3><p>MIUI+我没用过，好像是用于跨平台写作的，好像还有点用。</p><p>小米互传主要作用是在手机间互传文件，想与电脑互传就有点麻烦了。</p><p>而一般我们想要拿回系统动画和高斯模糊，会使用第三方的桌面，但是即便换一个桌面也不能弥补控制中心这个系统界面部分没有高斯模糊的遗憾。其实这方面的阉割是受一些系统属性控制的，在MIUI时期有些手机上甚至关闭MIUI优化即可拿回全部的高斯模糊和系统动画。</p><p>就在数小时前，我加入的刷机群群主已经将修改这些属性与恢复MIUI+和小米互传的功能写了个Magisk模块出来。</p><blockquote><p>Tips：刷入前需提前安装zip中的MIUI+和小米互传，否则会卡米（亲测）</p></blockquote><p>在刷入后确实能让低端机的高斯模糊和原系统桌面的动画回归，MIUI+与小米互传也都能用了，非常的Nice。再次感谢群主与群友orz。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>低端机的功能恢复还是略显麻烦，希望小米长点心，不要阉割的啥都不剩。作为一个低端机的使用者还是希望小米能积极进取，不要固步自封，为低端机用户带来更好的体验。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HyperOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender学习日志 01</title>
    <link href="/2024/02/16/blender-log-01/"/>
    <url>/2024/02/16/blender-log-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用工具记录 03 双拼输入法</title>
    <link href="/2024/02/14/tools-log-03/"/>
    <url>/2024/02/14/tools-log-03/</url>
    
    <content type="html"><![CDATA[<h2 id="双拼是什么"><a href="#双拼是什么" class="headerlink" title="双拼是什么"></a>双拼是什么</h2><p>我们都知道现代汉字的拼音是由声母和韵母组成，有点类似于英语的元音辅音。</p><p>在传统的全拼输入法中我们要确定一个拼音需要将其打全，比如“全”这个字，需要按q、u、a、n四个键才能打出来（不考虑智能联想的情况下），而双拼呢，就是使用俩个键来确定一个拼音，自然码双拼中打“全”只需要输入q、r就行。</p><p>每个双拼方案都有自己独特的韵母键位，当然我最喜欢的是自然码双拼，在Windows上和安卓的gboard中都自带。</p><h2 id="为什么要学双拼"><a href="#为什么要学双拼" class="headerlink" title="为什么要学双拼"></a>为什么要学双拼</h2><p>双拼首先一个就是打字打起来比全拼快一点，重码率也低了一点，更不容易打错字了，其次就是键盘的敲击次数显著减少了，打字更轻松了，最后就是可以让不懂的人无法使用你的设备打中文恶作剧。</p><h2 id="双拼方案"><a href="#双拼方案" class="headerlink" title="双拼方案"></a>双拼方案</h2><p>在初学双拼时可能会纠结学哪个双拼方案，我觉得适合自己的才是最好的，像我不想折腾，就选择了我可以随手找到的自然码双拼，并且自然码双拼也只使用二十六个字母的键位，这点比较符合我的喜好。如果喜欢比较新一点的双拼方案也可以用小鹤双拼或者小鹤音形，后者是前者的plus版本。</p><h2 id="如何练习"><a href="#如何练习" class="headerlink" title="如何练习"></a>如何练习</h2><p>初学可以使用<a href="https://api.ihint.me/shuang/">这个网站</a>练习，大概了解了键位可以尝试使用双拼和人聊天，养成习惯即可。其实双拼很快就可以上手的（前提是你的拼音没还给语文老师）。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双拼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity UI 开发日志 01</title>
    <link href="/2024/02/14/unity-ui-log-01/"/>
    <url>/2024/02/14/unity-ui-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="选择哪个-UI-方案？"><a href="#选择哪个-UI-方案？" class="headerlink" title="选择哪个 UI 方案？"></a>选择哪个 UI 方案？</h2><p>在 Unity 中，有三种 UI 开发框架可选，其一是最新的 UI Toolkit，然后是 UGUI，最后是 IMGUI。</p><p>它们三者有何不同呢？在 Unity 官方文档里已经给出了解答：</p><ul><li><p>UI Toolkit 适合程序员和 UI 设计师，类似 Web 的 UI 设计对习惯基于 GameObject 的工具和工作流的技术美术不是那么友好。</p></li><li><p>UGUI 适合程序员和技术美术，同理对不熟悉 GameObject 的 UI 设计师不是那么友好。</p></li><li><p>IMGUI 只适合程序员，对技术美术和 UI 设计师都不怎么友好。</p></li></ul><blockquote><p>另外：UI Toolkit 更适合需要适配不同分辨率的覆盖屏幕型的 UI，UGUI 更适合游戏世界内 UI 和 VR 的 UI 还有那些需要自定义 shader 或材质实现的 UI。</p></blockquote><p>我们按照官方文档的顺序，先来学习 UI Toolkit。</p><h2 id="Unity-中-UI-的种类"><a href="#Unity-中-UI-的种类" class="headerlink" title="Unity 中 UI 的种类"></a>Unity 中 UI 的种类</h2><p>Unity 中我们可以为游戏创建 UI，也可以给 Unity 编辑器创建新的 UI。也就是<code>Runtime UI</code>和<code>Editor UI</code>的区别。</p><h2 id="UI-Toolkit"><a href="#UI-Toolkit" class="headerlink" title="UI Toolkit"></a>UI Toolkit</h2><h3 id="Editor-UI"><a href="#Editor-UI" class="headerlink" title="Editor UI"></a>Editor UI</h3><h4 id="新建-Editor-Window"><a href="#新建-Editor-Window" class="headerlink" title="新建 Editor Window"></a>新建 Editor Window</h4><p>我们先打开 Unity，以任意模板新建一个项目，然后在资源管理器里右键选择 <code>Create &gt; UI Toolkit &gt; Editor Window</code>，在弹出的窗口里的 C#一栏输入 <code>MyCustomEditor</code>，将 USS 栏的<strong>✓</strong>取消掉，最后点击 Confirm 创建。</p><h4 id="为-Editor-Window-创建-UI"><a href="#为-Editor-Window-创建-UI" class="headerlink" title="为 Editor Window 创建 UI"></a>为 Editor Window 创建 UI</h4><p>有三种方法为 Window 添加 UI，它们分别是 UI Builder 可视化编辑、UXML 文本编辑、C#代码编辑。</p><h5 id="UI-Builder-可视化编辑"><a href="#UI-Builder-可视化编辑" class="headerlink" title="UI Builder 可视化编辑"></a>UI Builder 可视化编辑</h5><p>点击图中这个 Open 来打开 UI Builder。</p><p><img src="https://s2.loli.net/2024/11/21/AR9zBa8qxiDj7ed.png" alt="这个界面是检查器窗口"></p><p>这个是个人都会，在在左边拖动控件放下就是了。我们重点讲一下另外俩个。</p><h5 id="UXML-文本编辑"><a href="#UXML-文本编辑" class="headerlink" title="UXML 文本编辑"></a>UXML 文本编辑</h5><p>我们在 Assets 下按顺序点击 <code>Create &gt; UI Toolkit &gt; UI Document</code>，将其命名为<code>MyCustomEditor_UXML</code>。</p><p>我们点击它右边的那个箭头，会弹出一个叫 inline style 的东西，我们点击它会自动跳转到外部文本编辑器。</p><p><img src="https://s2.loli.net/2024/11/21/N75XOhwAUYDLiCQ.png" alt="展开前"></p><p><img src="https://s2.loli.net/2024/11/21/wu3yPpIo6TVmj7b.png" alt="展开后"></p><p>然后我们可以在里面添加一些内容，标签大概长这样。</p><p><img src="https://s2.loli.net/2024/11/21/sigk9AvCVZ3Dcul.png" alt="代码长这样"></p><p>然后我们需要更改 Editor Window 的 C#代码来让其加载这个 UXML 文件。</p><p>编辑<code>MyCustomEditor.cs</code>，在类中添加以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">SerializeField</span>]<br><span class="hljs-keyword">private</span> VisualTreeAsset m_UXMLTree;<br></code></pre></td></tr></table></figure><p>并在 <strong>CreateGUI()</strong> 方法主体的最后加上这行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">root.Add(m_UXMLTree.Instantiate());<br></code></pre></td></tr></table></figure><p>然后我们在资源管理器中选中 <code>MyCustomEditor.cs</code> ，在右侧的检查器中将 <code>UXML Tree</code>设置成 <code>MyCustomEditor_UXML.uxml</code> 。</p><p>然后我们再查看<code>Window &gt; UI Toolkit &gt; MyCustomEditor</code>就能看到我们用 UXML 写的编辑器 UI 了。</p><p><img src="https://s2.loli.net/2024/11/21/v8bLG3afME2he9p.png" alt="窗口长这样"></p><h5 id="C-代码编辑"><a href="#C-代码编辑" class="headerlink" title="C#代码编辑"></a>C#代码编辑</h5><p>作为程序员最喜欢的应该就是用代码来操控所有的东西了。而 Unity UI Toolkit 也允许我们用代码来创建销毁或调整控件。</p><p>打开<code>MyCustomEditor.cs</code>，我们可以看到 using 里面有一行<code>using UnityEngine.UIElements</code>，这个是添加 UI 所必须加的引用。</p><p>在 CreateUI() 方法里我么可以看到<code>VisualElement root = rootVisualElement</code>，要向窗口增加 UI，我们需要先创建 UI 对象并给它们添加一些属性，然后使用这个<code>root</code>的** Add() **方法来将 UI 添加到窗口。</p><p>例子如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateGUI</span>()</span><br>&#123;<br>    <span class="hljs-comment">// Each editor window contains a root VisualElement object</span><br>    VisualElement root = rootVisualElement;<br><br>    <span class="hljs-comment">// VisualElements objects can contain other VisualElements following a tree hierarchy.</span><br>    Label label = <span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;这时由 C#创建的文本&quot;</span>);<br>    root.Add(label);<br><br>    Button button = <span class="hljs-keyword">new</span> Button();<br>    button.name = <span class="hljs-string">&quot;button_cs&quot;</span>;<br>    button.text = <span class="hljs-string">&quot;这是由 C#创建的按钮&quot;</span>;<br>    root.Add(button);<br><br>    Toggle toggle = <span class="hljs-keyword">new</span> Toggle();<br>    toggle.name = <span class="hljs-string">&quot;toggle_cs&quot;</span>;<br>    toggle.label = <span class="hljs-string">&quot;这是由 C#创建的勾选项&quot;</span>;<br>    root.Add(toggle);<br><br>    <span class="hljs-comment">// Import UXML</span><br>    <span class="hljs-keyword">var</span> visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(<span class="hljs-string">&quot;Assets/Editor/MyCustomEditor.uxml&quot;</span>);<br>    VisualElement labelFromUXML = visualTree.Instantiate();<br>    root.Add(labelFromUXML);<br><br>    root.Add(m_UXMLTree.Instantiate());<br>&#125;<br></code></pre></td></tr></table></figure><p>保存后重新打开窗口我们可以看到效果：</p><p><img src="https://s2.loli.net/2024/11/21/LmWedVfAk2PrQFj.png" alt="C#版本"></p><h4 id="为-UI-添加控制"><a href="#为-UI-添加控制" class="headerlink" title="为 UI 添加控制"></a>为 UI 添加控制</h4><p>最终的 C#代码长这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UIElements;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomEditor</span> : <span class="hljs-title">EditorWindow</span><br>&#123;<br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Window/UI Toolkit/MyCustomEditor&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowExample</span>()</span><br>    &#123;<br>        MyCustomEditor wnd = GetWindow&lt;MyCustomEditor&gt;();<br>        wnd.titleContent = <span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;MyCustomEditor&quot;</span>);<br>    &#125;<br><br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> VisualTreeAsset m_UXMLTree;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_ClickCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> m_ButtonPrefix = <span class="hljs-string">&quot;button&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateGUI</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Each editor window contains a root VisualElement object</span><br>        VisualElement root = rootVisualElement;<br><br>        <span class="hljs-comment">// VisualElements objects can contain other VisualElement following a tree hierarchy.</span><br>        Label label = <span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;These controls were created using C# code.&quot;</span>);<br>        root.Add(label);<br><br>        Button button = <span class="hljs-keyword">new</span> Button();<br>        button.name = <span class="hljs-string">&quot;button3&quot;</span>;<br>        button.text = <span class="hljs-string">&quot;This is button3.&quot;</span>;<br>        root.Add(button);<br><br>        Toggle toggle = <span class="hljs-keyword">new</span> Toggle();<br>        toggle.name = <span class="hljs-string">&quot;toggle3&quot;</span>;<br>        toggle.label = <span class="hljs-string">&quot;Number?&quot;</span>;<br>        root.Add(toggle);<br><br>        <span class="hljs-comment">// Import UXML</span><br>        <span class="hljs-keyword">var</span> visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(<span class="hljs-string">&quot;Assets/Editor/MyCustomEditor.uxml&quot;</span>);<br>        VisualElement labelFromUXML = visualTree.Instantiate();<br>        root.Add(labelFromUXML);<br><br>        root.Add(m_UXMLTree.Instantiate());<br><br>        <span class="hljs-comment">//Call the event handler</span><br>        SetupButtonHandler();<br>    &#125;<br><br>    <span class="hljs-comment">//Functions as the event handlers for your button click and number counts</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetupButtonHandler</span>()</span><br>    &#123;<br>        VisualElement root = rootVisualElement;<br><br>        <span class="hljs-keyword">var</span> buttons = root.Query&lt;Button&gt;();<br>        buttons.ForEach(RegisterHandler);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterHandler</span>(<span class="hljs-params">Button button</span>)</span><br>    &#123;<br>        button.RegisterCallback&lt;ClickEvent&gt;(PrintClickMessage);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintClickMessage</span>(<span class="hljs-params">ClickEvent evt</span>)</span><br>    &#123;<br>        VisualElement root = rootVisualElement;<br><br>        ++m_ClickCount;<br><br>        <span class="hljs-comment">//Because of the names we gave the buttons and toggles, we can use the</span><br>        <span class="hljs-comment">//button name to find the toggle name.</span><br>        Button button = evt.currentTarget <span class="hljs-keyword">as</span> Button;<br>        <span class="hljs-built_in">string</span> buttonNumber = button.name.Substring(m_ButtonPrefix.Length);<br>        <span class="hljs-built_in">string</span> toggleName = <span class="hljs-string">&quot;toggle&quot;</span> + buttonNumber;<br>        Toggle toggle = root.Q&lt;Toggle&gt;(toggleName);<br><br>        Debug.Log(<span class="hljs-string">&quot;Button was clicked!&quot;</span> +<br>            (toggle.<span class="hljs-keyword">value</span> ? <span class="hljs-string">&quot; Count: &quot;</span> + m_ClickCount : <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下节我们学习 UI Builder 的一些具体使用。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity插件开发日志 01</title>
    <link href="/2024/02/14/unity-plug-log-01/"/>
    <url>/2024/02/14/unity-plug-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity插件"><a href="#Unity插件" class="headerlink" title="Unity插件"></a>Unity插件</h2><p>这里说的插件不是官方文档脚本部分里的那个插件，而是我们开发游戏时用于扩展编辑器功能的插件。很多时候我们会发现Unity并不自带某些我们需要的功能，这时我们需要去资源商店或其他地方找别人写好的插件安装，来让自己的Unity得到这些本来没有的功能。今天呢我们就来自己写一个Unity插件吧。</p><h2 id="写什么插件"><a href="#写什么插件" class="headerlink" title="写什么插件"></a>写什么插件</h2><p>关于写什么插件，我思来想去最后想到了，我们来写一个控制台插件，我玩过的很多游戏都有控制台，但是Unity并不自带类似的东西，游戏在发行后我们没有办法显式地即时控制。</p><h2 id="插件结构"><a href="#插件结构" class="headerlink" title="插件结构"></a>插件结构</h2><p>首先我们需要为自己的插件定一个结构，比如这样：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">ConsolePlugin<br>|- Scripts<br>|- |- XXX.cs<br>|- UI<br>|- |- XXX.cs<br>|- Utils<br>|- |- XXX.cs<br>|- ConsolePlugin.cs<br></code></pre></td></tr></table></figure><p>其中<strong>Scripts</strong>目录下的是这个插件的主要逻辑代码，<strong>UI</strong>则是UI方面的代码和资产，<strong>Utils</strong>则是一些适合分离出来复用的模块，最后的<strong>ConsolePlugin.cs</strong>是插件与Unity对接的一个接口。确定了目录结构，我们现在就可以开始写插件了。</p><h2 id="编写-ConsolePlugin-cs"><a href="#编写-ConsolePlugin-cs" class="headerlink" title="编写 ConsolePlugin.cs"></a>编写 ConsolePlugin.cs</h2><p>这个与Unity对接的脚本我们肯定是要最先写好的，我们在这个脚本中应该包含给编辑器使用的UI和逻辑，UI我们会用到IMGUI。</p><p>首先我们需要引入Unity编辑器，<code>using UnityEditor;</code>，然后我们先创建插件专属的菜单栏。只需要定义一个static void的函数，在其前面带上[MenuItem]属性即可，比如下面这个：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Console/Toggle&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConsoleToggle</span>()</span><br>&#123;<br>   Debug.Log(<span class="hljs-string">&quot;Console toggled&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>保存编译后你会发现你Unity的菜单栏多出了一项，里面也有我们定义的子项。</p><p><img src="/ConsoleToggle.png" alt="如图"></p><p>点击它我们也会看到编辑器的控制台输出了我们定义的文本。</p><p><img src="/ConsoleToggleResult.png" alt="如图"></p><p>MenuItem这个特性的参数还可以定义选项卡的打开方式，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//_i：表示没有组合键，直接按住键盘&quot;i&quot;使用</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Console/Inspector _i&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConsoleInspector</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Opening Console Inspector&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//#d：表示按住 Shift + d 使用</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Console/Debug #d&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConsoleDebug</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Starting Console Debug mode&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//%w：表示按住 Ctrl + w 使用</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Console/Window %w&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConsoleWindow</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Opening Console window&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//&amp;a：表示按住 Alt + a 使用</span><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Console/About &amp;a&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConsoleAbout</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Show plugin developer&#x27;s information&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图：</p><p><img src="/ConsoleMenu.png"></p><h2 id="编写-UI-Editor-ConsoleEditorWindow-cs"><a href="#编写-UI-Editor-ConsoleEditorWindow-cs" class="headerlink" title="编写 UI&#x2F;Editor&#x2F;ConsoleEditorWindow.cs"></a>编写 UI&#x2F;Editor&#x2F;ConsoleEditorWindow.cs</h2><p>接下来我们编写编辑器这边的窗口。</p><p>首先我们还是需要引用<strong>UnityEditor</strong>，然后我们需要将类的基类改成<strong>EditorWindow</strong>，也就是class的声明变成：<code>public class ConsoleEditorWindow : EditorWindow</code></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 美化日志 01</title>
    <link href="/2024/02/13/vscode-log-01/"/>
    <url>/2024/02/13/vscode-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么用-VSCode？"><a href="#为什么用-VSCode？" class="headerlink" title="为什么用 VSCode？"></a>为什么用 VSCode？</h2><p>原因很简单，因为它用起来简单。装个扩展随便点几下鼠标的事不会有人不喜欢吧？如果真的有那我只能说你 lua（or vim or elisp）脚本写少了。</p><p>还有一个重要原因就是 VSCode 的颜值确实高，看看我的 VSCode。<br><img src="https://s2.loli.net/2024/11/21/PTjRQiZysM4KWe1.png" alt="我的 VSCode">  </p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="扩展安装"><a href="#扩展安装" class="headerlink" title="扩展安装"></a>扩展安装</h3><ol><li>打开 VSCode，按下 <code>Ctrl+Shift+X</code> 打开扩展市场：</li><li>搜索安装如下扩展：<ul><li>GlassIt-VSC<br> <img src="https://s2.loli.net/2024/11/21/znw728mUJa4cWos.png" alt="GlassIt-VSC">  </li><li>One Dark Pro<br> <img src="https://s2.loli.net/2024/11/21/hYnskpWNtDjZSH4.png" alt="One Dark Pro"></li></ul></li></ol><h3 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h3><ol><li>打开 VSCode，按下 <code>Ctrl+K Ctrl+T</code> 打开主题设置。</li><li>选择 <code>One Dark Pro</code> 主题。我这里用的设<code>One Dark Pro Darker</code>, 个人感觉配色更加好看。</li></ol><h3 id="VSCode-设置"><a href="#VSCode-设置" class="headerlink" title="VSCode 设置"></a>VSCode 设置</h3><p>去设置里把这项改成<code>Top</code>，就会把堆积在左边的 sidebar 全部收到顶部，这样就能让你的 VSCode 看起来更加舒服。 </p><p><img src="https://s2.loli.net/2024/11/21/lIxyUN2XAZvR1FQ.png" alt="边栏位置">  </p><p>还有就是把目录树的缩进增加一些，不然的话当文件层级变多，会有点难区分层级关系。</p><p><img src="https://s2.loli.net/2024/11/21/vC92VHpzrsutAi8.png" alt="缩进">  </p><h3 id="WallPaper-Engine"><a href="#WallPaper-Engine" class="headerlink" title="WallPaper Engine"></a>WallPaper Engine</h3><p>我们去 steam 买个 WallPaper Engine，然后在上面安装个好看的壁纸，这样 GlassIt-VSC 就能让 VSCode 的背景变成壁纸了。</p><p><img src="https://s2.loli.net/2024/11/21/7jFSoYHXNJ5V9M2.png" alt="WallPaper Engine">  </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 学习日志 01</title>
    <link href="/2024/02/12/kotlin-log-01/"/>
    <url>/2024/02/12/kotlin-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Kotlin-是什么"><a href="#Kotlin-是什么" class="headerlink" title="Kotlin 是什么"></a>Kotlin 是什么</h2><p>Kotlin是一门高级编程语言，多的不说，主要用于替代Java进行安卓开发，现在由JetBrains维护。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>学一门语言，先学Hello World。</p><p>Kotlin的Hello World相比Java简单了不少：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br>    println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>跟很多其他高级语言一样，普通的kotlin以main为入口函数，<strong>fun</strong>则是函数的关键字，函数需要花括号包裹，kotlin内置了<strong>print</strong>和<strong>println</strong>这两个函数作为输出函数，后者输出时会自动在末尾添加一个换行符，函数的调用是使用圆括号。</p><p>下一篇学习Kotlin的基本语法。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>澎湃OS折腾日志 01</title>
    <link href="/2024/02/09/hyperos-log-01/"/>
    <url>/2024/02/09/hyperos-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="关于为什么回来搞HyperOS"><a href="#关于为什么回来搞HyperOS" class="headerlink" title="关于为什么回来搞HyperOS"></a>关于为什么回来搞HyperOS</h2><p>类原生小bug实在太多了，而且HyperOS其实优化的不错了，实测no google的国内版本开机也才30%的物理内存占用。</p><h2 id="先Root"><a href="#先Root" class="headerlink" title="先Root"></a>先Root</h2><p>安卓设备Root都差不多的，我也还是用我之前的方案，也就是Kitsune Mask + KernelSU，可以参考我之前写的博客。</p><h2 id="Magisk-模块"><a href="#Magisk-模块" class="headerlink" title="Magisk 模块"></a>Magisk 模块</h2><h3 id="LSPosed-框架"><a href="#LSPosed-框架" class="headerlink" title="LSPosed 框架"></a>LSPosed 框架</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>师承XPosed，以应用的形式安装模块，给系统带来更多功能。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在<a href="https://github.com/LSPosed/LSPosed/releases">这里</a>下载最新版本，在magisk中刷入，记得开启magisk设置中的zygisk将magisk注入zygote。</p><p>在重启后查看通知，里面有LSPosed发的通知（如果没有，拨号键盘里输入<code>*#*#5776733#*#*</code>来打开寄生管理器），点击即可进入寄生管理器，设置里有创建桌面快捷方式。</p><h3 id="充电加速v6"><a href="#充电加速v6" class="headerlink" title="充电加速v6"></a>充电加速v6</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>关闭阶梯式充电，提高平均充电功率，但是要小心手机爆炸，对于低瓦数充电的手机十分实用。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>Scene的Magisk模块界面里搜索充电加速就能找到下载链接。</p><h3 id="A1Memory（A1内存管理）"><a href="#A1Memory（A1内存管理）" class="headerlink" title="A1Memory（A1内存管理）"></a>A1Memory（A1内存管理）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>A1内存管理模块能在保证不杀后台的前提下提高可用内存空间，配合墓碑模块和ZRAM可以几乎不杀后台应用。</p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p>访问<a href="https://github.com/OneB1ank/A1Memory/releases">这里</a>下载最新的发行版本。下载完成后到Magisk中刷入即可。</p><p>还附带了一个LSPosed模块，可以去启用一下。</p><h3 id="Uperf-Game-Turbo（YC调度改版）"><a href="#Uperf-Game-Turbo（YC调度改版）" class="headerlink" title="Uperf Game Turbo（YC调度改版）"></a>Uperf Game Turbo（YC调度改版）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>因为官方版YC调度已经停更数年，民间的YC调度改版层出不穷，而这个改版是Scene官方支持的调度之一。</p><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><p>在<a href="https://github.com/yinwanxi/Uperf-Game-Turbo/releases">这里</a>下载后刷入即可。</p><h3 id="Scene-Magisk模块"><a href="#Scene-Magisk模块" class="headerlink" title="Scene Magisk模块"></a>Scene Magisk模块</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>Scene自带了几个Magisk模块可以直接刷入，提供了一些实用功能。如Magisk模块救砖和移除温控。</p><h4 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h4><p>在Scene的附加功能下的杂项中可以看到俩个Magisk模块的选项。</p><p>自动救砖模块点击后就会直接安装，而删除温控模块可以自己选择需要删除哪些温控（注意.so文件不能删！）</p><h2 id="LSPosed-模块"><a href="#LSPosed-模块" class="headerlink" title="LSPosed 模块"></a>LSPosed 模块</h2><h3 id="NoActive（墓碑模块）"><a href="#NoActive（墓碑模块）" class="headerlink" title="NoActive（墓碑模块）"></a>NoActive（墓碑模块）</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>iOS的后台都是除服务外的应用进程都会暂停执行，不占用CPU，也就是所谓的墓碑后台。</p><p>NoActive就是使用Linux内核中的cgroup实现类似iOS墓碑后台的效果的模块。</p><p>配合A1内存管理可以获得超越iOS的后台能力。</p><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><p><a href="https://app.myflv.cn/guide/start.html">这篇官方博客</a>写的非常详细。大致上就是安装NoActive模块和刷入<strong>Millet配置模块</strong>。</p><h3 id="HyperCeiler"><a href="#HyperCeiler" class="headerlink" title="HyperCeiler"></a>HyperCeiler</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>Ceimiuiler（西米露）的澎湃新版本，适配了澎湃OS，添加了许多功能。</p><h4 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h4><p>在LSPosed的仓库界面可以找到下载安装。安装完成后即可开始系统改造。</p><h2 id="冻结APP"><a href="#冻结APP" class="headerlink" title="冻结APP"></a>冻结APP</h2><p>冻结一些不必要的应用可以省出更多内存，减少耗电量，以下是我推荐的APP冻结列表（仅供参考）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs txt">游戏中心<br>百度输入法小米版<br>讯飞输入法小米版<br>搜狗输入法小米版<br>小米画报<br>钱包<br>服务与反馈<br>内容中心<br>小米云盘<br>用户反馈<br>小米有品<br>小米云备份<br>小米云服务<br>系统安全组件<br>快应用服务框架<br>小米智能卡<br>小米智能卡网页组件<br>智能服务<br>生活黄页<br>售后支持<br>米币支付<br>蜻蜓FM<br>小米运动健康<br>Analytics<br>Joyose<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>澎湃OS的底子还是不错的，毕竟是最新的安卓14底层，从安卓12开始的3代安卓都有比较明显的改进。而且也能做到较好的性能释放和续航。如果你哪天不想用类原生又不想用系统级谷歌服务了兴许可以刷回澎湃OS。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HyperOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chroot容器研究日志 01</title>
    <link href="/2024/01/30/chroot-log-01/"/>
    <url>/2024/01/30/chroot-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是chroot容器？"><a href="#什么是chroot容器？" class="headerlink" title="什么是chroot容器？"></a>什么是chroot容器？</h2><p>chroot是Linux发行版中一个用于将进程隔离在一个受限空间的软件，而由于将进程隔离到了受限空间中，我们只需要将系统运行所必要的分区挂载在这个隔离出来的受限空间中就可以使用chroot运行一个与宿主系统共用内核的容器系统了。内核基于Linux的安卓系统当然也是可以使用chroot的，但是需要root权限。接下来我们就来在已root的安卓设备上安装一个Linux容器吧。</p><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><h3 id="Root权限"><a href="#Root权限" class="headerlink" title="Root权限"></a>Root权限</h3><p>首先你的安卓手机需要获得root权限，这里就不说了，可以看看我的其他博客。</p><h3 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h3><p>然后你需要一个终端模拟器来操作root shell，建议使用<strong>termux</strong>。</p><p>首次进入termux中，我们先换国内源来提高下载速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">termux-change-repo<br></code></pre></td></tr></table></figure><p><strong>使用上下箭头键来切换选项，使用空格选中选项，回车键确定选项</strong>，选tsinghua（清华大学）、ustc（中国科技大学）、bfsu（北京外国语大学）等大学的源即可。</p><p>回车后会自动更新源索引文件，我们再手动更新下自带软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pkg upgrade -y<br><span class="hljs-comment"># 可简化成</span><br>pkg up -y<br></code></pre></td></tr></table></figure><p>然后再运行一次<code>termux-change-repo</code>，选<strong>Single Mirror</strong>，将我们之前选的镜像源再选中确定一次。</p><p>使用以下命令给termux赋予存储读写权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">termux-setup-storage<br></code></pre></td></tr></table></figure><h3 id="必要软件"><a href="#必要软件" class="headerlink" title="必要软件"></a>必要软件</h3><p>如果想使用Magisk赋予termux root权限，那么需要使用<strong>tsu</strong>来申请root权限。</p><blockquote><p>Tips：KernelSU可直接跳过此步，在KernelSU的管理器中给termux root权限并重新启动termux即可</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pkg install tsu -y<br><span class="hljs-comment"># 可简化成</span><br>pkg i tsu -y<br><span class="hljs-comment"># 从Magisk获取root权限</span><br>tsu<br></code></pre></td></tr></table></figure><h2 id="下载rootfs"><a href="#下载rootfs" class="headerlink" title="下载rootfs"></a>下载rootfs</h2><p>这里我们选择<strong>Arch Linux ARM</strong>系统来作为我们的容器系统，我们在<a href="https://archlinuxarm.org/about/downloads">官网</a>可以下载到，一般的安卓设备选择名称为<strong>ARMv8 AArch64 Multi-platform</strong>、文件名为<strong>ArchLinuxARM-aarch64-latest.tar.gz</strong>的rootfs下载即可。</p><p>可以在termux里使用<strong>wget</strong>或者<strong>curl</strong>下载，或者用安卓自带浏览器下载，只要你知道下载到哪里就行。</p><h2 id="解压rootfs"><a href="#解压rootfs" class="headerlink" title="解压rootfs"></a>解压rootfs</h2><p>我们首先创建一个用于存放容器文件系统的目录，这里我选择在 <strong>&#x2F;data&#x2F;linux</strong> 下创建一个叫 <strong>arch</strong> 的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先进入root shell</span><br>su<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> -p /data/linux/arch<br></code></pre></td></tr></table></figure><p>然后我们将下载的rootfs压缩包解压缩到这个目录中（假设你已经<code>cd</code>到了下载压缩包的目录）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxpf ArchLinuxARM-aarch64-latest.tar.gz -C /data/linux/arch/<br></code></pre></td></tr></table></figure><h2 id="创建-dev-shm"><a href="#创建-dev-shm" class="headerlink" title="创建&#x2F;dev&#x2F;shm"></a>创建&#x2F;dev&#x2F;shm</h2><p>因为我们可能会用chroot容器来运行一些基于chromium内核的软件，比如electron应用以及chromium本体，所以我们需要创建<code>/dev/shm</code>这个目录来让这些软件能够正常运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在宿主机文件系统中创建</span><br><span class="hljs-built_in">mkdir</span> /dev/shm<br><span class="hljs-comment"># 在容器文件系统中创建</span><br><span class="hljs-built_in">mkdir</span> /data/linux/arch/dev/shm<br></code></pre></td></tr></table></figure><h2 id="编写启动脚本"><a href="#编写启动脚本" class="headerlink" title="编写启动脚本"></a>编写启动脚本</h2><p>我们需要挂载一些宿主机的分区到容器系统才能驱动让其成为一个独立运行的容器，所以我们来编辑chroot容器的启动脚本。我们先使用<code>exit</code>来退出root shell，然后输入<code>nano a</code>来创建并编辑一个名叫<strong>a</strong>的脚本文件，在其中输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>ARCHPATH=/data/linux/arch<br>TERMUX_PREFIX=/data/data/com.termux/files/usr<br>mount -o remount,dev,suid /data<br>mount -t tmpfs -o size=256M /dev/shm <span class="hljs-variable">$ARCHPATH</span>/dev/shm<br>mount -o <span class="hljs-built_in">bind</span> /dev <span class="hljs-variable">$ARCHPATH</span>/dev<br>mount -t devpts devpts <span class="hljs-variable">$ARCHPATH</span>/dev/pts<br>mount -o <span class="hljs-built_in">bind</span> /sys <span class="hljs-variable">$ARCHPATH</span>/sys<br>mount -o <span class="hljs-built_in">bind</span> /proc <span class="hljs-variable">$ARCHPATH</span>/proc<br>mount -t tmpfs tmpfs <span class="hljs-variable">$ARCHPATH</span>/tmp<br><span class="hljs-built_in">chroot</span> <span class="hljs-variable">$ARCHPATH</span> /bin/su - root<br>umount -f <span class="hljs-variable">$ARCHPATH</span>/dev/pts<br>umount -f <span class="hljs-variable">$ARCHPATH</span>/dev<br>umount -f <span class="hljs-variable">$ARCHPATH</span>/sys<br>umount -f <span class="hljs-variable">$ARCHPATH</span>/proc<br></code></pre></td></tr></table></figure><h2 id="新建用户与配置用户组"><a href="#新建用户与配置用户组" class="headerlink" title="新建用户与配置用户组"></a>新建用户与配置用户组</h2><p>作为一个“普通”的Linux用户，我们肯定不能在平常用root用户的，我们进容器后第一件事就是创建一个新的用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -s /bin/bash axis<br>passwd axis<br><span class="hljs-comment"># 建议顺便也改下root用户的密码</span><br>passwd root<br></code></pre></td></tr></table></figure><p>axis是我自己定的用户名。</p><p>Android只允许在某些用户组里的用户执行某些操作，在chroot容器中也是如此。</p><p>使用以下命令添加用户组并将新建的用户加入其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd -g 3001 android_bt<br>groupadd -g 3002 android_bt-net<br>groupadd -g 3003 android_inet<br>groupadd -g 3004 android_net-raw<br>groupadd -g 1015 sdcard-rw<br>groupadd -g 1028 sdcard-r<br>gpasswd -a axis android_bt<br>gpasswd -a axis android_bt-net<br>gpasswd -a axis android_inet<br>gpasswd -a axis android_net-raw<br>gpasswd -a axis sdcard-rw<br>gpasswd -a axis sdcard-r<br></code></pre></td></tr></table></figure><p>大功告成之后我们不急着换用户，先用着root，可以少打点sudo和密码。</p><blockquote><p>如果需要这个普通用户在使用root权限运行命令时不需要输入密码，可以自行编辑 &#x2F;etc&#x2F;sudoers，当然你需要先使用pacman安装sudo后才会有这个文件，因为容器系统里并不自带sudo这个软件。</p></blockquote><h2 id="解决DNS问题"><a href="#解决DNS问题" class="headerlink" title="解决DNS问题"></a>解决DNS问题</h2><p><code>/etc/resolv.conf</code>默认是一个链接到<code>/run/systemd/resolve/resolv.conf</code>的链接，而我们chroot容器是没有systemd的，所以我们需要重新创建<code>/etc/resolv.conf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /etc/resolv.conf<br><span class="hljs-built_in">touch</span> /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>我们<code>nano /etc/resolv.conf</code>来编辑一下里面的内容，加入以下几行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 谷歌DNS</span><br>nameserver 8.8.8.8<br><span class="hljs-comment"># 国内高速DNS</span><br>nameserver 114.114.114.114<br></code></pre></td></tr></table></figure><p>如果不解决DNS的问题，我们在第二次启动容器时会连不上网络。</p><h2 id="更新系统软件"><a href="#更新系统软件" class="headerlink" title="更新系统软件"></a>更新系统软件</h2><p>在使用pacman更新系统软件之前，我们先导入公钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key --init<br>pacman-key --populate<br></code></pre></td></tr></table></figure><p>导入完成后就可以愉快的更新了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在更新前可以编辑 /etc/pacman.conf 将 ParallelDownloads = 5 取消注释以提高下载速度</span><br>pacman -Syyu base-devel --noconfirm<br></code></pre></td></tr></table></figure><blockquote><p>Tips：如遇到error: could not determine cachedir mount point &#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg 的情况，需要编辑 &#x2F;etc&#x2F;pacman.confg，将其中的CheckSpace注释起来。</p></blockquote><h2 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h2><p>ArchLinuxARM默认的软件源在国外，对大陆用户不太友好，这时我们可以替换为大陆的镜像源来提高pacman的下载速度。</p><p>将<code>/etc/pacman.d/</code>下的<code>mirrorlist</code>改名为<code>mirrorlist.bak</code>来备份下原本的软件源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak<br></code></pre></td></tr></table></figure><p>重新创建并编辑<code>/etc/pacman.d/mirrorlist</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>在其中加入以下几行从tmoe脚本那抄过来的软件源：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">## Archlinux arm<br>Server = https://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repo<br>Server = https://mirror.archlinuxarm.org/$arch/$repo<br>Server = https://mirrors.bfsu.edu.cn/archlinuxarm/$arch/$repo<br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/$arch/$repo<br>Server = https://mirrors.163.com/archlinuxarm/$arch/$repo<br></code></pre></td></tr></table></figure><p>编辑完保存后我们使用<code>pacman -Syu</code>来更新一下。</p><p>我们还可以添加一些额外的软件源，比如archlinuxcn、arch4edu、blackarch，我们编辑<code>/etc/pacman.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /etc/pacman.conf<br></code></pre></td></tr></table></figure><p>在文件末尾加入以下文本：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs txt">[arch4edu]<br>Server = https://mirrors.bfsu.edu.cn/arch4edu/$arch<br>Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch<br>Server = https://mirror.autisten.club/arch4edu/$arch<br>Server = https://arch4edu.keybase.pub/$arch<br>Server = https://mirror.lesviallon.fr/arch4edu/$arch<br>Server = https://mirrors.tencent.com/arch4edu/$arch<br>SigLevel = Never<br>[archlinuxcn]<br>Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch<br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch<br>Server = https://repo.archlinuxcn.org/$arch<br>SigLevel = Never<br>[blackarch]<br>Server = https://mirrors.ustc.edu.cn/blackarch/$repo/os/$arch<br>Server = https://mirrors.tuna.tsinghua.edu.cn/blackarch/$repo/os/$arch<br>Server = https://mirrors.aliyun.com/blackarch/$repo/os/$arch<br>Server = https://www.blackarch.org/blackarch/$repo/os/$arch<br>SigLevel = Never<br></code></pre></td></tr></table></figure><h2 id="配置语言"><a href="#配置语言" class="headerlink" title="配置语言"></a>配置语言</h2><p>容器的默认语言是英文，如果需要将其改成中文，我们需要手动生成语言包并将系统语言配置成中文。</p><p>编辑<code>/etc/locale.gen</code>，找到<code>zh_CN.UTF-8</code>，将这俩行取消注释。</p><p>在shell中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo locale-gen<br></code></pre></td></tr></table></figure><p>等待生成完毕，我们编辑<code>/etc/locale.conf</code>，将其中的<code>LANG=C</code>替换成<code>LANG=zh_CN.UTF-8</code>，之后重启容器即可。</p><h2 id="配置时区"><a href="#配置时区" class="headerlink" title="配置时区"></a>配置时区</h2><p>如果你在容器里使用date命令你会发现你的容器内时间是不对的，是标准的零时区时间，为了同步我们自己的时间，我们需要把时区文件软链接到<code>/etc/localtime</code>来改变容器的系统时区。</p><p>时区文件在<code>/usr/share/zoneinfo/</code>下，我们需要在下面找到符合我们时区的城市。北京时间的设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -svf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure><p>之后重启容器即可。</p><blockquote><p>在容器内用<code>exit</code>可以退出容器回到termux，在termux中输入<code>./a</code>则可以启动容器。</p></blockquote><h2 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h2><p>我们装个xfce来当图形界面，因为只装WM真的太折磨人了，你连壁纸软件都得另外装，可能还不如装xfce这种轻量化的DE。使用以下命令在Arch中安装xfce桌面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syu xfce4 xfce4-goodies<br></code></pre></td></tr></table></figure><h2 id="精简系统"><a href="#精简系统" class="headerlink" title="精简系统"></a>精简系统</h2><p>对于一个不需要引导和加载的容器系统来说，**&#x2F;boot**分区里的东西直接删了都没关系，另外，我们也不需要更新 <strong>ramdisk</strong>，所以我们可以直接卸载 <strong>mkinitcpio</strong> 和删除 <strong>&#x2F;boot</strong> 分区下的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Rsc mkinitcpio<br>sudo <span class="hljs-built_in">rm</span> -rf /boot/*<br></code></pre></td></tr></table></figure><p>这么整可以省出几百MB的存储空间，还是很香的。</p><h2 id="访问宿主机内部存储"><a href="#访问宿主机内部存储" class="headerlink" title="访问宿主机内部存储"></a>访问宿主机内部存储</h2><p>有时我们需要在容器内访问宿主机的内部存储，用外部的文件管理器将文件复制进容器里显然很不方便。</p><p>我们可以通过挂载宿主机的内部存储来让容器可以访问宿主机的内部存储，在容器的启动脚本中chroot前加入下面这行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su -c <span class="hljs-string">&quot;mkdir <span class="hljs-variable">$ARCHPATH</span>/sdcard&quot;</span><br>su -c <span class="hljs-string">&quot;mount -o bind /data/media/0 <span class="hljs-variable">$ARCHPATH</span>/sdcard&quot;</span><br></code></pre></td></tr></table></figure><p>这样宿主机的内部存储就会被挂载到容器的<code>/sdcard</code>目录。</p><h2 id="使用termux-x11显示图形界面"><a href="#使用termux-x11显示图形界面" class="headerlink" title="使用termux-x11显示图形界面"></a>使用termux-x11显示图形界面</h2><p>将启动脚本中的<code>mount -t tmpfs tmpfs $ARCHPATH/tmp</code>改为<code>mount -o bind $TERMUX_PREFIX/tmp $ARCHPATH/tmp</code>。</p><p>然后我建议启动容器时将selinux设置成宽容模式，并将&#x2F;tmp取消挂载，这样不会产生一些莫名其妙的bug，然后为了少打个su来启动root终端，因为我换到了kernelsu，不用tsu了，所以直接用<code>su -c &quot;&quot;</code>来用root权限运行命令。最终的容器启动脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>ARCHPATH=/data/linux/arch<br>TERMUX_PREFIX=/data/data/com.termux/files/usr<br><span class="hljs-comment"># KernelSU 可注释下行</span><br>su -c <span class="hljs-string">&quot;setenforce permissive&quot;</span><br>su -c <span class="hljs-string">&quot;mount -o remount,dev,suid /data&quot;</span><br>su -c <span class="hljs-string">&quot;mount -t tmpfs -o size=256M /dev/shm <span class="hljs-variable">$ARCHPATH</span>/dev/shm&quot;</span><br>su -c <span class="hljs-string">&quot;mount -o bind /dev <span class="hljs-variable">$ARCHPATH</span>/dev&quot;</span><br>su -c <span class="hljs-string">&quot;mount -t devpts devpts <span class="hljs-variable">$ARCHPATH</span>/dev/pts&quot;</span><br>su -c <span class="hljs-string">&quot;mount -o bind /sys <span class="hljs-variable">$ARCHPATH</span>/sys&quot;</span><br>su -c <span class="hljs-string">&quot;mount -o bind /proc <span class="hljs-variable">$ARCHPATH</span>/proc&quot;</span><br>su -c <span class="hljs-string">&quot;mount -o bind <span class="hljs-variable">$TERMUX_PREFIX</span>/tmp <span class="hljs-variable">$ARCHPATH</span>/tmp&quot;</span><br>pkill -f <span class="hljs-string">&quot;/system/bin/app_process / com.termux.x11.Loader :0 -ac&quot;</span><br><span class="hljs-built_in">nohup</span> termux-x11 :0 -ac &gt;/dev/null 2&gt;&amp;1 &amp;<br>su -c <span class="hljs-string">&quot;chroot <span class="hljs-variable">$ARCHPATH</span> /bin/su - axis&quot;</span><br>su -c <span class="hljs-string">&quot;umount -f <span class="hljs-variable">$ARCHPATH</span>/dev/pts&quot;</span><br>su -c <span class="hljs-string">&quot;umount -f <span class="hljs-variable">$ARCHPATH</span>/dev&quot;</span><br>su -c <span class="hljs-string">&quot;umount -f <span class="hljs-variable">$ARCHPATH</span>/sys&quot;</span><br>su -c <span class="hljs-string">&quot;umount -f <span class="hljs-variable">$ARCHPATH</span>/proc&quot;</span><br>su -c <span class="hljs-string">&quot;umount -f <span class="hljs-variable">$ARCHPATH</span>/tmp&quot;</span><br><span class="hljs-comment"># KernelSU 可注释下行</span><br>su -c <span class="hljs-string">&quot;setenforce enforcing&quot;</span><br></code></pre></td></tr></table></figure><p>记得在容器内的<code>/etc/profile</code>的末尾添加此行来让挂载的tmp目录在容器内可读写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 /tmp<br></code></pre></td></tr></table></figure><h2 id="卸载chroot容器"><a href="#卸载chroot容器" class="headerlink" title="卸载chroot容器"></a>卸载chroot容器</h2><p>怎么卸载一个chroot容器呢？步骤很简单。</p><ol><li><strong>重启设备（强制重置所有挂载，因为<code>umount</code>有时并不发挥作用）</strong></li><li><strong>删除容器目录(即<code>rm -rf 容器所对应的目录</code>)</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chroot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发学习 02</title>
    <link href="/2024/01/25/android-log-02/"/>
    <url>/2024/01/25/android-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="Jetpack-Compose"><a href="#Jetpack-Compose" class="headerlink" title="Jetpack Compose"></a>Jetpack Compose</h2><p>安卓开发现在有两种主要架构，一种是跟传统的Java开发类似，只是将开发语言换成了Kotlin，而另一种是全新的声明式UI架构，也就是Jetpack Compose，用Compose可以不用写繁杂的xml布局代码，直接使用代码来构建布局，并能在构建布局的同时编写控件逻辑，极大提高了工作效率。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们创建一个Jetpack Compose的项目</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Avalonia 学习&amp;开发日志 02</title>
    <link href="/2024/01/25/avalonia-log-02/"/>
    <url>/2024/01/25/avalonia-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="新建一个View"><a href="#新建一个View" class="headerlink" title="新建一个View"></a>新建一个View</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Avalonia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo美化学习日志 01</title>
    <link href="/2024/01/24/hexo-beautify-log-01/"/>
    <url>/2024/01/24/hexo-beautify-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要美化hexo？"><a href="#为什么需要美化hexo？" class="headerlink" title="为什么需要美化hexo？"></a>为什么需要美化hexo？</h2><p>hexo的默认主题虽然还行，但是缺少一些必要的功能，视觉效果上也不一定符合每个人的胃口。所以为了对自己的眼镜好一点，我们来美化hexo吧！</p><h2 id="使用hexo主题"><a href="#使用hexo主题" class="headerlink" title="使用hexo主题"></a>使用hexo主题</h2><p>hexo提供了丰富的主题可供我们选择，在<a href="https://hexo.io/themes/">这里</a>可以看到各个主题的开源地址和展示网页。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓Root学习日志 01</title>
    <link href="/2024/01/23/android-rooting-log-01/"/>
    <url>/2024/01/23/android-rooting-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Root"><a href="#什么是Root" class="headerlink" title="什么是Root"></a>什么是Root</h2><p>root是Linux系统中拥有最高权限的用户，可以在系统中进行任意操作而不用担心授权问题。</p><p>而在基于Linux内核开发的Android中，root却并不开放给普通用户使用。因此让普通用户获取root用户的权限成为了成为了安卓玩机的一个重要课题。</p><h2 id="主流Root方式"><a href="#主流Root方式" class="headerlink" title="主流Root方式"></a>主流Root方式</h2><p>主流的Root方式：</p><ul><li>KingRoot等一键root（Android 2.2 ~ Android 5.1）</li><li>SuperSU（Android 5.0 ~ Android 7.1）</li><li>Magisk（Android 5.0以上）</li><li>KernelSU（仅官方支持内核版本5.10以上的Android，其余可自行编译）</li><li>APatch（内核版本3.18 ~ 6.1的Android）</li></ul><h2 id="个人认为目前最好的root方案"><a href="#个人认为目前最好的root方案" class="headerlink" title="个人认为目前最好的root方案"></a>个人认为目前最好的root方案</h2><p>个人认为现在最用的是<strong>Kitsune Mask + KernelSU</strong>，Kitsune面具是Magisk的改版，自带magisk隐藏，而KernelSU是内核层面上的root，且它有一套App Profile系统，能更好的管理root权限，避免授予root应用更多权限，提高root应用的安全性。</p><h2 id="Root-步骤"><a href="#Root-步骤" class="headerlink" title="Root 步骤"></a>Root 步骤</h2><blockquote><p>所有root的前提都是解锁bootloader，若未解锁bootloader则无法获得永久的root</p></blockquote><h3 id="Kitsune-Mask"><a href="#Kitsune-Mask" class="headerlink" title="Kitsune Mask"></a>Kitsune Mask</h3><h4 id="提取boot-img"><a href="#提取boot-img" class="headerlink" title="提取boot.img"></a>提取boot.img</h4><p>首先你要提取现在使用的ROM的<strong>boot.img</strong>，米系手机ROM网上一大堆，找到自己的现在装的版本下载下来就好了，线刷包（一般为tgz后缀）解压后在<strong>images</strong>文件夹下就可找到<strong>boot.img</strong>，卡刷包（一般为zip后缀）解压后可以看到里面有个叫作<strong>payload.bin</strong>的文件，需要用特殊的软件来解包这个文件，比如<strong>payload-dumper-go</strong>，在<a href="https://github.com/ssut/payload-dumper-go/releases">这里</a>可以下载安装，仓库readme里也有说怎么使用我就不提了。</p><h4 id="修补boot-img"><a href="#修补boot-img" class="headerlink" title="修补boot.img"></a>修补boot.img</h4><p>将上一步提取的boot.img传到手机上，接着在手机上安装<a href="https://github.com/HuskyDG/magisk-files/releases">Kitsune Mask</a>，然后点击Magisk选项卡右侧的Install，Method选Select and Patch a file，选择boot.img等待修补，修补完成后将生成一个叫作<strong>magisk_patched-*.img</strong>的文件。</p><h4 id="刷入修补后的boot-img"><a href="#刷入修补后的boot-img" class="headerlink" title="刷入修补后的boot.img"></a>刷入修补后的boot.img</h4><p>将上一步最后提到的修补后的img文件传输到电脑。电脑上使用fastboot刷入：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">fastboot flash boot magisk_patched_*.img<br></code></pre></td></tr></table></figure><p>刷完后输入：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">fastboot reboot<br></code></pre></td></tr></table></figure><p>来重启手机</p><h4 id="修复环境"><a href="#修复环境" class="headerlink" title="修复环境"></a>修复环境</h4><p>进系统后再次进Kitsune Mask，会弹出修复环境的对话框，点确定后等待重启即可。</p><h3 id="KernelSU"><a href="#KernelSU" class="headerlink" title="KernelSU"></a>KernelSU</h3><h4 id="下载对应的内核镜像"><a href="#下载对应的内核镜像" class="headerlink" title="下载对应的内核镜像"></a>下载对应的内核镜像</h4><p>刷好Kitsune Mask之后我们可以使用<a href="https://github.com/capntrips/KernelFlasher/releases">Kernel Flasher</a>直接刷入AnyKernel3的内核，内核的具体版本要看ROM的内核版本，一般只要对应好俩个参数即可：安卓内核版本号，如android12，需要注意内核的android版本不一定跟ROM一致，如ROM是安卓13但内核可能为android12、Linux内核版本，如5.10.198，尽量选择三段都一致的内核刷入。</p><h4 id="刷入内核镜像文件"><a href="#刷入内核镜像文件" class="headerlink" title="刷入内核镜像文件"></a>刷入内核镜像文件</h4><p>Kernel Flasher中找到活动插槽，选择下载好的AnyKernel3内核文件刷入后重启即可安装KernelSU。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓CPU调教日志 01</title>
    <link href="/2024/01/23/android-cpu-enhance-log-01/"/>
    <url>/2024/01/23/android-cpu-enhance-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="在安卓上我们能对CPU干什么？"><a href="#在安卓上我们能对CPU干什么？" class="headerlink" title="在安卓上我们能对CPU干什么？"></a>在安卓上我们能对CPU干什么？</h2><p>在获取到root权限之后，我们可以调节安卓系统的温控和CPU调度来让CPU在保证一定算力的情况下降低功耗，达到性能续航两不误。当然我们不是自己写代码控制这些，我们可以使用<strong>scene</strong>这款软件来调节这些东西。</p><h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><ol><li>使用任意方式Root手机 </li><li>去<a href="https://vtools.omarea.com/">scene官网</a>下载最新版本的scene，目前最新版本为<strong>scene7</strong></li></ol><h2 id="以Root权限运行scene"><a href="#以Root权限运行scene" class="headerlink" title="以Root权限运行scene"></a>以Root权限运行scene</h2><p>我使用的Root方案是<strong>KernelSU</strong>，我们在KernelSU管理器里点击底部导航栏的超级用户，找到scene，为其勾选超级用户选项。</p><h2 id="安装第三方调度"><a href="#安装第三方调度" class="headerlink" title="安装第三方调度"></a>安装第三方调度</h2><p>scene本身自带了俩个调度，但是在一些机型上自带调度表现不好，虽然可以使用图形界面自定义调度，但是并不够灵活，不能实时变更CPU调速器，会导致续航降低，并不能在相同性能情况下实现最好的续航。</p><p>这时我们可以找一些第三方调度，安卓最知名的第三方CPU调度：YC调度——Uperf已经停止更新很久了，不适配现在的手机CPU与系统，现在不建议使用，我们可以找到以YC调度为基底开发的其他第三方调度，如Uperf Game Turbo、Violent Uperf、Crazy Uperf等。</p><p>这里推荐使用Uperf Game Turbo，是发展了有一段时间的Uperf改版。</p><p>我们在scene的调度界面点击小齿轮，里面就可以找到Uperf Game Turbo的下载链接。</p><p>下载zip以后我们去KSU中刷入，刷入过程中会提示安装AsoulGameOpt，建议也安装一下。</p><p>刷入后重启手机，再进入scene的调度界面，会发现调度自动切换为了Uperf Game Turbo。</p><h2 id="Uperf-Game-Turbo"><a href="#Uperf-Game-Turbo" class="headerlink" title="Uperf Game Turbo"></a>Uperf Game Turbo</h2><p>对于这些已经开发好的第三方调度我们能改动的东西并不算多，主要是应用策略方面的调整，为合适的app选择合适的模式就是我们需要做的，建议全局默认改为均衡模式。</p><p>下一篇我们讲讲怎么自己写一个第三方调度。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓刷机学习日志 01</title>
    <link href="/2024/01/23/android-flashing-log-01/"/>
    <url>/2024/01/23/android-flashing-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="安卓刷机的意义"><a href="#安卓刷机的意义" class="headerlink" title="安卓刷机的意义"></a>安卓刷机的意义</h2><p>一般来说，国内安卓手机厂商的ROM都带有不少的限制，比如杀不掉的后台进程和服务啦、烦人的系统推送啦、恶心人的云控啦等等。而第三方的基于国内ROM的修改版ROM或者类原生ROM都没有这些毛病，并且提供很多个性化的设置（虽然不一定比官方ROM好）。</p><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><h3 id="一台可以解锁BootLoader的手机"><a href="#一台可以解锁BootLoader的手机" class="headerlink" title="一台可以解锁BootLoader的手机"></a>一台可以解锁BootLoader的手机</h3><p>我使用的是一台内存配置为8+128GB的<strong>Redmi Note12R</strong>，CPU是<strong>骁龙4gen2</strong>，在低端机里算是很能打的了，但是小米官方对它预装的MIUI14进行了阉割，就算root了换了民间大神的系统桌面还用模块伪装成了高端机型，系统界面（控制中心）的背景依然是一个灰色的遮罩，非常的丑。</p><h3 id="解锁BootLoader"><a href="#解锁BootLoader" class="headerlink" title="解锁BootLoader"></a>解锁BootLoader</h3><blockquote><p>重要提醒：解锁Bootloader会丢失手机的所有数据，请提前做好备份！！！</p></blockquote><p>我们在<strong>设置</strong>中的<strong>关于手机</strong>界面点击全部参数，然后连续点击<strong>MIUI版本</strong>这一栏<strong>7</strong>次打开<strong>开发者选项</strong>，然后在设置中找到开发者选项，找到选项<strong>查看设备解锁状态</strong>，然后按文字提示操作申请解锁BootLoader即可。</p><p>等待7天后我们在Windows电脑上下载安装<strong>小米解锁助手</strong>，登录小米账号后选择解锁手机。手机关机后<strong>长按音量下键 + 关机键</strong>进入<strong>Fastboot</strong>模式，手机屏幕此时会显示橙色的<strong>FASTBOOT</strong>字样，这时将手机使用数据线连接到电脑的USB接口上，当电脑屏幕上显示找到设备后我们点击解锁设备即可开始解锁，等待一段时间等进度条满了显示解锁成功即表示本设备已成功解锁BootLoader。</p><h3 id="开启OEM解锁"><a href="#开启OEM解锁" class="headerlink" title="开启OEM解锁"></a>开启OEM解锁</h3><p>在<strong>开发者选项</strong>中找到<strong>OEM解锁</strong>，启用后重启手机。</p><h3 id="找一个合适的ROM"><a href="#找一个合适的ROM" class="headerlink" title="找一个合适的ROM"></a>找一个合适的ROM</h3><p>MIUI有很多第三方的官改ROM，但官改系统大部分不支持低端机，而且官改系统不是开源系统，无法保证里面是否藏有锁机或格机的程序。</p><p>鉴于以上原因，我最终将目光转向了开源的类原生ROM。遗憾的是大名鼎鼎的<strong>LineageOS</strong>并不支持我的这部Redmi Note12R及其衍生机型。所以在多方查找后，我选择了一个冷门但有官方支持的类原生ROM——<strong>Bliss ROM</strong>。</p><p>这台Redmi Note12R可以刷入基于 <strong>Android 14</strong> 的 <strong>Bliss ROM 17</strong>，而且还带gapps。在<a href="https://sourceforge.net/projects/blissroms/files/Universe/sky/">这里</a>可以下载到。</p><h3 id="TWRP"><a href="#TWRP" class="headerlink" title="TWRP"></a>TWRP</h3><p><strong>TWRP</strong>是一个开源的第三方Recovery程序，我们需要使用第三方Recovery才能刷入非官方的ROM，否则会无法进入系统。红米Note12R暂时没有官方的TWRP，第三方倒是有适配，网上搜吧，我就不提供链接了。</p><h2 id="开始刷机"><a href="#开始刷机" class="headerlink" title="开始刷机"></a>开始刷机</h2><h3 id="准备文件与工具"><a href="#准备文件与工具" class="headerlink" title="准备文件与工具"></a>准备文件与工具</h3><p>在<a href="https://developer.android.google.cn/tools/releases/platform-tools?hl=zh-cn#downloads">这里</a>下载Android platform-tools，解压后里面有我们刷机需要的<strong>adb</strong>和<strong>fastboot</strong>（这个也可以用miui解锁助手文件夹里的）</p><p>为了减少低级错误发生的可能性，我们先把要刷的ROM卡刷包和TWRP放在platform-tools的文件夹下面。</p><h3 id="退出小米账号"><a href="#退出小米账号" class="headerlink" title="退出小米账号"></a>退出小米账号</h3><p>在开始刷机前我们先退出小米账号以防一些莫名其妙的问题。</p><h3 id="进入Fastboot"><a href="#进入Fastboot" class="headerlink" title="进入Fastboot"></a>进入Fastboot</h3><p>我们将手机关机，<strong>长按音量下键+关机键</strong>进入橙色的<strong>FASTBOOT</strong>模式。</p><h3 id="刷入TWRP-Recovery"><a href="#刷入TWRP-Recovery" class="headerlink" title="刷入TWRP Recovery"></a>刷入TWRP Recovery</h3><p>我们先在Windows CMD或PowerShell中切换到platform-tools的目录，这里假设我们把它解压到了D盘的根目录下（实际情况要看你自己解压到哪里），那么我们应该输入：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">cd</span> D:\platform-tools<br></code></pre></td></tr></table></figure><p>我们在开发者选项中打开<strong>USB调试</strong>选项，然后我们将手机用数据线连接电脑的USB接口。</p><p>在命令窗口输入命令将手机重启到bootloader：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\adb.exe reboot bootloader<br></code></pre></td></tr></table></figure><p>接着我们输入以下命令来查看设备是否有成功被识别：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\fastboot.exe devices<br></code></pre></td></tr></table></figure><p>如果显示出一个表，前面一列的是乱码后面一列显示device则表示电脑连接成功。</p><p>这时我们输入：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\fastboot.exe flash recovery_a twrp.img<br>.\fastboot.exe flash recovery_b twrp.img<br>.\fastboot.exe reboot recovery<br></code></pre></td></tr></table></figure><blockquote><p>注：其中twrp.img请根据实际文件名，善用鼠标和tab补全</p></blockquote><p>这时我们会成功进入到TWRP的界面。</p><p>右侧有个language选项里面可以选择简体中文。</p><p>我们输入手机锁屏密码进入TWRP。</p><h3 id="线刷ROM卡刷包"><a href="#线刷ROM卡刷包" class="headerlink" title="线刷ROM卡刷包"></a>线刷ROM卡刷包</h3><p>在这一步我们需要用到一个叫作<strong>adb sideload</strong>的功能。</p><p>在TWRP的左下角，有个叫<strong>Advanced（中文为“高级”）</strong>的选项。我们点进去，里面有我们要找的adb sideload。</p><p>我们点击adb sideload，上面有两个选项，我们先勾一下，然后滑动下方的拖动条启动adb sideload。</p><p>看到<code>Starting adb sideload feature</code>或<code>启动adb sideload中</code>就表示adb sideload已经启动了。</p><p>这时我们回到电脑这边来，在命令行输入：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\adb sideload rom.img<br></code></pre></td></tr></table></figure><blockquote><p>其中rom.img是ROM卡刷包的名称，善用鼠标和tab补全</p></blockquote><p>等待刷入完成后手机上的日志会有几个报红，这是正常现象，下方会显示个按钮叫我们Reboot或者重启，点击那个按钮重启就可以了。</p><h3 id="清除数据"><a href="#清除数据" class="headerlink" title="清除数据"></a>清除数据</h3><p>如果无法进入系统，重启到TWRP后双清，清除完后重启，即可进入线刷的第三方ROM。</p><h3 id="刷机完成"><a href="#刷机完成" class="headerlink" title="刷机完成"></a>刷机完成</h3><p>如果你看到了第三方ROM的开机动画，这时就代表你已经刷机成功了！</p><h2 id="Bliss，启动！"><a href="#Bliss，启动！" class="headerlink" title="Bliss，启动！"></a>Bliss，启动！</h2><p>因为Bliss的这个包是自带gapps的，所以我们第一次进的时候不要连wifi，不然可能会因为没有魔法而卡在谷歌认证。建议进系统后自行安装梯子软件。经过一些简单的设置我们就可以进入系统了。</p><p>至此我们已经完成了Bliss ROM在红米Note12R上的刷入。</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Avalonia 学习&amp;开发日志 01</title>
    <link href="/2024/01/22/avalonia-log-01/"/>
    <url>/2024/01/22/avalonia-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Avalonia-是什么？"><a href="#Avalonia-是什么？" class="headerlink" title="Avalonia 是什么？"></a>Avalonia 是什么？</h2><p>Avalonia 是基于.Net的一个跨平台应用开发框架。</p><p>我们平常开发桌面应用一般都是什么平台用什么框架，比如Windows上就用WinForm、WPF或UWP，Linux上就用qt或gtk等等，但是当我们的应用需要同时在几个平台上跑时，使用这些应用开发框架来开发就显得力不从心了。现在最火的桌面跨平台开发框架应该是Electron，但是嘛，这玩意它体积大，性能在没优化的情况下也是很烂的，毕竟是浏览器。</p><p>而Avalonia使用MVVM这种成熟的架构和C#等.Net语言，C#是目前最强的应用开发语言，不管是性能还是易用性，它都是最强的，而MVVM这种架构已经在WPF上经过验证，是很方便开发和维护的一种架构。而Avalonia这个民间框架，做到了微软最新的MAUI都没能做出来的特性：跨所有主流平台，不止桌面端三兄弟，移动端的俩座大山它也支持，不像MAUI现在还不支持Linux。</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>我们先来尝试桌面端的开发。我们使用Windows系统上的Visual Studio作为开发环境的代码编辑器。</p><blockquote><p>注意：这里默认你已经安装好了VS 2022。如果你还没安装好赶紧去安装吧，记得把它装到固态硬盘里（非系统盘）</p></blockquote><p>我们首先要做的是，在Visual　Studio　Installer里点击已安装的VS选项卡下的修改按钮，在工作负荷标签页下选择安装**.Net桌面开发**，然后我们打开命令提示符程序输入</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">dotnet new install Avalonia.Templates<br></code></pre></td></tr></table></figure><p>来安装Avalonia的模板。</p><p>我们还需要进到VS中，在标签页<strong>扩展-&gt;管理扩展</strong>下搜索安装<strong>Avalonia for Visual Studio 2022</strong>这个扩展，下载完成后关闭VS2022，等待VSIX Installer响应，在弹出的窗口中点击<strong>Modify</strong>来安装。</p><p>到此基础开发环境已搭建完成。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在VS的启动窗口中选择<strong>创建新的解决方案或项目</strong>，在模板选择上方的搜索栏输入<strong>Avalonia</strong>来检索模板，找到<strong>Avalonia MVVM Application</strong>，下方标签带有<strong>C#<strong>的模板后点击右下角的下一部，输入项目名称，我们以官方的待办事项示例为例，输入</strong>ToDoList</strong>，点击下一步，在这个页面的配置一般不用动，直接创建项目。</p><p>创建的新MVVM项目会自动打开axaml布局文件，但是布局设计器需要构建一次项目才能使用，所以右半边屏幕的布局设计器会报错，点击报错下的<strong>build</strong>构建一次项目即可显示。</p><p>创建完成后的项目目录长这个样子：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ToDoList<br> |<span class="hljs-string">- Assets</span><br><span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">- avalonia-logo.ico</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- Models</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- ViewModels</span><br><span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">- MainWindowViewModel.cs</span><br><span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">- ViewModelBase.cs</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- Views</span><br><span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">- MainWindow.axaml</span><br><span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">  </span>|<span class="hljs-string">- MainWindow.axaml.cs</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- App.axaml</span><br><span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">- App.axaml.cs</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- app.manifest</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- Program.cs</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- ViewLocator.cs</span><br><span class="hljs-string"> </span>|<span class="hljs-string">- ToDoList.csproj</span><br></code></pre></td></tr></table></figure><p>今天就水到这里了，休息去喽~</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Avalonia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Dots 学习日志 04</title>
    <link href="/2023/10/08/unity-dots-log-04/"/>
    <url>/2023/10/08/unity-dots-log-04/</url>
    
    <content type="html"><![CDATA[<h2 id="Dots踩坑记录"><a href="#Dots踩坑记录" class="headerlink" title="Dots踩坑记录"></a>Dots踩坑记录</h2><p>因为我们要把输入存为IComponentData支持的类型，所以我们需要使用ReadValue<T>来从InputAction中读取值，但是这里会遇到一个问题，当你只需要判断按键是否被按下时，你不能用到Button的那几个状态，因为IComponentData不支持。</p><p>翻看官方文档无果后经过搜索，我找到了Unity论坛里对这件事的讨论，其中有一位指出了Button的返回值是float类型，当按下时为1，未按下时为0，所以我们只需要<code>ReadValue&lt;float&gt;</code>即可将按键的按下状态存储为Component了。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习日志 02</title>
    <link href="/2023/09/11/c-log-02/"/>
    <url>/2023/09/11/c-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="类型（Type）"><a href="#类型（Type）" class="headerlink" title="类型（Type）"></a>类型（Type）</h2><p>C语言是一种强类型的语言，处理的每个数据都必须有明确的类型。</p><p>C语言自带的类型有非常多，在讲类型之前我们先来了解一下C语言中的变量。</p><h2 id="变量（Variable）"><a href="#变量（Variable）" class="headerlink" title="变量（Variable）"></a>变量（Variable）</h2><p>变量是承载数据的容器，而变量的类型就是数据的类型。</p><p>在C语言中，要创建一个变量，首先要声明它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">type name;<br></code></pre></td></tr></table></figure><p>type是变量的类型，name是变量名。</p><p>而我们可以给已声明的变量赋值（定义变量）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">name = value;<br></code></pre></td></tr></table></figure><p>name是已声明的变量的变量名，value是变量的值，值的范围和形式依变量的类型而定。</p><p>声明和定义可以和在一起，即在声明时进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">type name = value;<br></code></pre></td></tr></table></figure><p>C语言中有很多变量类型，我们先来看些基本的。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Dots学习日志 03</title>
    <link href="/2023/08/10/unity-dots-log-03/"/>
    <url>/2023/08/10/unity-dots-log-03/</url>
    
    <content type="html"><![CDATA[<h2 id="Dots实现FPS踩坑"><a href="#Dots实现FPS踩坑" class="headerlink" title="Dots实现FPS踩坑"></a>Dots实现FPS踩坑</h2><p>首当其冲的就是输入，可以使用input system，参考<a href="https://www.youtube.com/watch?v=bFHvgqLUDbE">油管大神<strong>TurboMakesGame</strong>的视频</a>。</p><p>这只是实现了移动的输入，视角转动的输入还没实现呢，这时我们会遇到一个问题，那就是camera。</p><p>将camera转化为entity，看似可行，实则不行，transform组件没被转化，实现了转不动（我已经试过了）。</p><p>经过多番查找，我发现，camera还是得留在subscene外继续当GameObject，我们把它当成一个普通的GameObject处理，那么怎么跟ECS对接呢？</p><p>这里我们可以参考<a href="https://www.youtube.com/watch?v=IO6_6Y_YUdE">油管大神<strong>TurboMakesGame</strong>的另一个视频</a>，在制作的最后部分有涉及camera control。</p><p>你以为能这样就完事了？并没有。</p><p>我们的camera不通过设置是看不到Entity的，我们需要去<strong>Edit &gt; Preferences &gt; Entities &gt; Baking</strong>下的<strong>Scene View Mode</strong>切换成<strong>Runtime Data</strong>。这样才能让我们的camera渲染出entity。</p><p>这就结束了？还没呢。因为player是Entity而camera是GameObject，所以我们并不能像在它们都是GameObject时那样通过将它们设置为父子物体来同步它们的transform，我们需要手动进行同步。</p><p>好了，我们先同步了位置，但是你会发现，视角转动和移动方向并没有关系，照抄大神的代码是不行的，我们还需要同步一下rotation。</p><p>写完同步rotation的代码，好嘛，运行起来一看，往下和往上看时player的模型也跟着上下转动，这是rotation的问题，我们不能同步所有的rotation数据。</p><p>解决方法是只同步camera rotation的quaternion的y和w值，其他两个设置为0，这会只同步水平方向的rotation。</p><p>至此我们才完成了一个基本的FPS角色移动和视角转动。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake学习日志 01</title>
    <link href="/2023/07/25/cmake-log-01/"/>
    <url>/2023/07/25/cmake-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="CMake是什么？"><a href="#CMake是什么？" class="headerlink" title="CMake是什么？"></a>CMake是什么？</h2><p>CMake是一个构建工具，一般用于构建C&#x2F;C++项目，它与传统Make的区别在于它提供了更简洁强大的配置文件语法，而且CMake是跨平台的，CMake也更符合现代C&#x2F;C++应用项目的需要，更适合于C&#x2F;C++的应用开发。JetBrains旗下的C&#x2F;C++ IDE——CLion默认就使用CMake进行项目构建。</p><h2 id="CMake基础语法"><a href="#CMake基础语法" class="headerlink" title="CMake基础语法"></a>CMake基础语法</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web开发日志 02</title>
    <link href="/2023/07/25/web-log-02/"/>
    <url>/2023/07/25/web-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS（Cascading Style Sheets，层叠样式表）是一种样式表语言，用于为HTML布局提供样式。虽然现在有很多框架用来提供一些组件化的CSS，但是了解基础也很重要。我们今天就来给HTML网页添加纯CSS来让它变得缤纷多彩。</p><h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><p>我们先从最简单的边缘样式开始。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* border */</span><br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br></code></pre></td></tr></table></figure><p><code>border</code> 是一个简写属性，可以同时设置 <code>border-width</code>、<code>border-style</code> 和 <code>border-color</code>。<code>border-width</code> 是边缘的宽度，<code>border-style</code> 是边缘的样式，<code>border-color</code> 是边缘的颜色。</p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>接下来我们来看 <code>padding</code> 属性，它用于设置元素内容与边缘之间的空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* padding */</span><br><span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br></code></pre></td></tr></table></figure><p><code>padding</code> 是一个简写属性，可以同时设置 <code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code> 和 <code>padding-left</code>。这里我们设置了所有边缘的 <code>padding</code> 为 10px。</p><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p><code>margin</code> 属性用于设置元素边缘与其它元素之间的空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* margin */</span><br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br></code></pre></td></tr></table></figure><p><code>margin</code> 是一个简写属性，可以同时设置 <code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code> 和 <code>margin-left</code>。这里我们设置了所有边缘的 <code>margin</code> 为 10px。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p><code>background</code> 属性用于设置元素的背景样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* background */</span><br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;background.jpg&#x27;</span>);<br><span class="hljs-attribute">background-repeat</span>: no-repeat;<br><span class="hljs-attribute">background-size</span>: cover;<br></code></pre></td></tr></table></figure><p><code>background-color</code> 设置背景颜色，<code>background-image</code> 设置背景图片，<code>background-repeat</code> 设置背景图片是否重复，<code>background-size</code> 设置背景图片的大小。</p><h2 id="font"><a href="#font" class="headerlink" title="font"></a>font</h2><p><code>font</code> 属性用于设置元素的字体样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* font */</span><br><span class="hljs-attribute">font-family</span>: Arial, sans-serif;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br><span class="hljs-attribute">font-weight</span>: bold;<br><span class="hljs-attribute">font-style</span>: italic;<br></code></pre></td></tr></table></figure><p><code>font-family</code> 设置字体，<code>font-size</code> 设置字体大小，<code>font-weight</code> 设置字体粗细，<code>font-style</code> 设置字体样式。</p><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><p><code>text</code> 属性用于设置元素的文本样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* text */</span><br><span class="hljs-attribute">text-align</span>: center;<br><span class="hljs-attribute">text-decoration</span>: underline;<br><span class="hljs-attribute">text-transform</span>: uppercase;<br></code></pre></td></tr></table></figure><p><code>text-align</code> 设置文本对齐方式，<code>text-decoration</code> 设置文本装饰，<code>text-transform</code> 设置文本转换。</p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p><code>display</code> 属性用于设置元素的显示方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* display */</span><br><span class="hljs-attribute">display</span>: block;<br><span class="hljs-attribute">display</span>: inline;<br><span class="hljs-attribute">display</span>: inline-block;<br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">display</span>: grid;<br></code></pre></td></tr></table></figure><p><code>display</code> 属性可以设置元素的显示方式，例如块级元素、内联元素、内联块级元素、弹性布局和网格布局。</p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p><code>position</code> 属性用于设置元素的定位方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* position */</span><br><span class="hljs-attribute">position</span>: static;<br><span class="hljs-attribute">position</span>: relative;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">position</span>: fixed;<br></code></pre></td></tr></table></figure><p><code>position</code> 属性可以设置元素的定位方式，例如静态定位、相对定位、绝对定位和固定定位。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们学习了CSS的一些基础属性，包括 <code>border</code>、<code>padding</code>、<code>margin</code>、<code>background</code>、<code>font</code>、<code>text</code>、<code>display</code> 和 <code>position</code>。这些属性可以帮助我们更好地控制网页的排版，使网页更加美观和易用。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语学习 02</title>
    <link href="/2023/07/21/jp-log-02/"/>
    <url>/2023/07/21/jp-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h2><p>日语中由辅音”k””s””t””n””h””m”””r””p””g””z””b”与半辅音”y”和元音”a””u””o”组合而成的音，如</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bspwm 配置 02</title>
    <link href="/2023/07/14/bspwm-log-02/"/>
    <url>/2023/07/14/bspwm-log-02/</url>
    
    <content type="html"><![CDATA[<h1 id="bspwm-配置-02"><a href="#bspwm-配置-02" class="headerlink" title="bspwm 配置 02"></a>bspwm 配置 02</h1><h1 id="sxhkd"><a href="#sxhkd" class="headerlink" title="sxhkd"></a>sxhkd</h1><p>sxhkd是bspwm配套的热键处理程序，我们现在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvim ~/.config/sxhkd/sxhkdrc<br></code></pre></td></tr></table></figure><p>可以看到以下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs txt">#<br># wm independent hotkeys<br>#<br><br># terminal emulator<br>super + Return<br>urxvt<br><br># program launcher<br>super + @space<br>dmenu_run<br><br># make sxhkd reload its configuration files:<br>super + Escape<br>pkill -USR1 -x sxhkd<br><br>#<br># bspwm hotkeys<br>#<br><br># quit/restart bspwm<br>super + alt + &#123;q,r&#125;<br>bspc &#123;quit,wm -r&#125;<br><br># close and kill<br>super + &#123;_,shift + &#125;w<br>bspc node -&#123;c,k&#125;<br><br># alternate between the tiled and monocle layout<br>super + m<br>bspc desktop -l next<br><br># send the newest marked node to the newest preselected node<br>super + y<br>bspc node newest.marked.local -n newest.!automatic.local<br><br># swap the current node and the biggest window<br>super + g<br>bspc node -s biggest.window<br><br>#<br># state/flags<br>#<br><br># set the window state<br>super + &#123;t,shift + t,s,f&#125;<br>bspc node -t &#123;tiled,pseudo_tiled,floating,fullscreen&#125;<br><br># set the node flags<br>super + ctrl + &#123;m,x,y,z&#125;<br>bspc node -g &#123;marked,locked,sticky,private&#125;<br><br>#<br># focus/swap<br>#<br><br># focus the node in the given direction<br>super + &#123;_,shift + &#125;&#123;h,j,k,l&#125;<br>bspc node -&#123;f,s&#125; &#123;west,south,north,east&#125;<br><br># focus the node for the given path jump<br>super + &#123;p,b,comma,period&#125;<br>bspc node -f @&#123;parent,brother,first,second&#125;<br><br># focus the next/previous window in the current desktop<br>super + &#123;_,shift + &#125;c<br>bspc node -f &#123;next,prev&#125;.local.!hidden.window<br><br># focus the next/previous desktop in the current monitor<br>super + bracket&#123;left,right&#125;<br>bspc desktop -f &#123;prev,next&#125;.local<br><br># focus the last node/desktop<br>super + &#123;grave,Tab&#125;<br>bspc &#123;node,desktop&#125; -f last<br><br># focus the older or newer node in the focus history<br>super + &#123;o,i&#125;<br>bspc wm -h off; \<br>bspc node &#123;older,newer&#125; -f; \<br>bspc wm -h on<br><br># focus or send to the given desktop<br>super + &#123;_,shift + &#125;&#123;1-9,0&#125;<br>bspc &#123;desktop -f,node -d&#125; &#x27;^&#123;1-9,10&#125;&#x27;<br><br>#<br># preselect<br>#<br><br># preselect the direction<br>super + ctrl + &#123;h,j,k,l&#125;<br>bspc node -p &#123;west,south,north,east&#125;<br><br># preselect the ratio<br>super + ctrl + &#123;1-9&#125;<br>bspc node -o 0.&#123;1-9&#125;<br><br># cancel the preselection for the focused node<br>super + ctrl + space<br>bspc node -p cancel<br><br># cancel the preselection for the focused desktop<br>super + ctrl + shift + space<br>bspc query -N -d | xargs -I id -n 1 bspc node id -p cancel<br><br>#<br># move/resize<br>#<br><br># expand a window by moving one of its side outward<br>super + alt + &#123;h,j,k,l&#125;<br>bspc node -z &#123;left -20 0,bottom 0 20,top 0 -20,right 20 0&#125;<br><br># contract a window by moving one of its side inward<br>super + alt + shift + &#123;h,j,k,l&#125;<br>bspc node -z &#123;right -20 0,top 0 20,bottom 0 -20,left 20 0&#125;<br><br># move a floating window<br>super + &#123;Left,Down,Up,Right&#125;<br>bspc node -v &#123;-20 0,0 20,0 -20,20 0&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个配置文件与bspwm不同，是有很多注释的，大家可以根据注释来自行进行配置。</p>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bspwm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用工具记录 02 Surfing Keys</title>
    <link href="/2023/07/12/tools-log-02/"/>
    <url>/2023/07/12/tools-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="Surfing-Keys"><a href="#Surfing-Keys" class="headerlink" title="Surfing Keys"></a>Surfing Keys</h2><p>Chrome 作为当下市场份额最高的浏览器，其有着丰富的软件生态。</p><p>其中的一个体现就是Chrome 有很多的浏览器扩展可以使用，本篇博客就来介绍一下<strong>Surfing Keys</strong>这个Chrome 扩展。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们去Chrome 的扩展商店搜索<strong>Surfing Keys</strong>，即可找到这个扩展，选择将其添加至Chrome 即可。</p><p>当然其他浏览器（比如火狐）也是有这个扩展的，去扩展商店也能安装。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Surfing Keys有很多操作与Vim 是一样的，作为一个NVimer 那肯定是很容易上手的，熟练之后就可以不用鼠标操作我们的Chrome 浏览器了，而且这个扩展的高级选项中还支持自定义配置文件，像我这种NVimer 很难不心动。</p><p>但是仍然存在一些问题，比如浏览器的一些自带页面（比如设置界面和无网络界面）是不允许使用扩展的，所以在这些界面时会无法使用Surfing Keys 对浏览器进行操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除开上述问题，Surfing Keys 这个扩展对于想要实现全键盘工作流的人来说是个不可多得的神器，能一定程度上提高操作浏览器的效率。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Dots 学习日志 02</title>
    <link href="/2023/07/06/unity-dots-log-02/"/>
    <url>/2023/07/06/unity-dots-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Dots-核心包"><a href="#安装Dots-核心包" class="headerlink" title="安装Dots 核心包"></a>安装Dots 核心包</h2><p>在Unity 编辑器界面，点击工具栏<strong>Windows &gt; Package Manager</strong>后点击左上角的**+<strong>号，选择</strong>Add package by name<strong>，在输入栏中输入</strong>com.unity.entities**即可安装Unity Entities 核心包。</p><p>然后我们是使用的URP模板创建的项目，所以我们还得安装另一个相关的包才能让我们的游戏对象正常渲染出来，这个渲染相关的包叫作<strong>com.unity.entities.graphics</strong></p><p>安装完Dots核心包之后不要忘了设定一下项目设置，在<strong>Edit &gt; Project Settings &gt; Editor</strong>下面，有个叫作<strong>Enter Play Mode Options</strong>的选项，我们把这个选项打开，然后里面的两个子选项（Reload Domain 和 Reload Scene）不用管它。设置完这个后会使场景和后台进程中的变量不再自动刷新，会影响带有static的函数或变量，对其他方面没有任何负面影响。</p><h2 id="Authoring-和-Runtime-数据"><a href="#Authoring-和-Runtime-数据" class="headerlink" title="Authoring 和 Runtime 数据"></a>Authoring 和 Runtime 数据</h2><p>unity dots严格的把数据分为了编辑模式下的Authoring类型数据和运行模式下的Runtime数据，在右侧的检查器（Inspector）面板，通常我们看到的是Authoring状态下的数据，而在运行模式下检查器面板会显示Runtime数据。</p><h2 id="Baker"><a href="#Baker" class="headerlink" title="Baker"></a>Baker</h2><p>因为在一般的unity开发流程中，我们的各种组件都继承自MonoBehaviour基类，而Dots使用的ECS是另一种架构，所以我们需要将普通的unity GameObject转化为ECS中的Entity，这个过程叫作<strong>Bake</strong>，而要Bake GameObject 我们需要创建一个Baker。</p><h3 id="编写Authoring脚本"><a href="#编写Authoring脚本" class="headerlink" title="编写Authoring脚本"></a>编写Authoring脚本</h3><p>我们一般在</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Dots 学习日志 01</title>
    <link href="/2023/07/06/unity-dots-log-01/"/>
    <url>/2023/07/06/unity-dots-log-01/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-Dots-学习日志-01"><a href="#Unity-Dots-学习日志-01" class="headerlink" title="Unity Dots 学习日志 01"></a>Unity Dots 学习日志 01</h1><p>我想用这篇博客来记录一下我学习使用Unity Dots来开发Unity 3D游戏的过程，我们将使用Unity Dots来开发一个FPS射击游戏的原型。</p><h1 id="Dots-相关概念"><a href="#Dots-相关概念" class="headerlink" title="Dots 相关概念"></a>Dots 相关概念</h1><p>首先我们来了解一些Unity Dots的相关概念，它与传统的Unity技术栈有何不同？</p><h2 id="面向数据设计（Data-Oriented-Design）"><a href="#面向数据设计（Data-Oriented-Design）" class="headerlink" title="面向数据设计（Data-Oriented Design）"></a>面向数据设计（Data-Oriented Design）</h2><p><strong>Data-Oriented Design</strong>简称<strong>DOD</strong>，是不同于面向对象编程&#x2F;设计（Object-Oriented Programming &#x2F; Design）的一种新兴的程序设计方法。</p><p>从字面上来看，DOP 从数据的角度来进行程序设计，而 OOP 则从对象的角度来进行程序设计。DOP 比OOP 更适合处理大量的数据，这刚好符合当代电子游戏的发展所带来的高性能需求。</p><p>但是DOP 缓存友好的优点也使使用它的代码更难编写和理解，需要开发者具备良好的计算机基础，熟悉内存（memory）、缓存（cache）等概念。</p><h2 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h2><p><strong>Entities</strong>是Unity Dots 的核心包，也是我们使用Dots 技术栈所主要学习的包。</p><h2 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h2><p><strong>Entity Component System</strong>是Entities 的核心架构，Entities 采用此架构来组织代码和数据。</p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>总而言之，Entity类似于GameObject，它可以挂载一个或多个Component。<br>创建或者销毁一个Entity会引发<strong>structrual change</strong>，具体我们后面再说。所有的Entity都由World中的<strong>EntityManager</strong>来管理。<br>Entity没有类型，但是可以通过与其相关的Components来分类。<br>EntityManager会记录已存在的Entity所具有的Components的集合，这些Components集合被称为<strong>Archetypes</strong>，我们后面也会讲到。</p><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>Component是用来给<strong>System</strong>读写的数据。</p><p>继承自接口<strong>IComponentData</strong>的结构体会被标记为Component类型。这种Component类型只储存非托管类型的数据，虽然这种Component可以储存方法，但是最好还是只储存纯净的数据。</p><p>当然也可以创建一个储存托管类型的Component，但是弊大于利，这里就不提了。</p><p>上面提到Entity所具有的Components的集合叫作<strong>Archetype</strong>，这里有个关键概念：<strong>Chunk</strong>，我们后面再说。</p><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System用于提供将Component从当前状态转换到下一状态的逻辑。例如根据所有移动的Entities的速度乘上一帧与当前帧之间的时间间隔来计算出它们这一帧的位置。</p><p>System在主线程上被每帧执行，然后是可以设定多个Systems之间的优先级的，我们可以自己决定谁先执行谁后执行。</p><p>System有四种可用类型：</p><ul><li><strong>SystemBase</strong>：用于创建托管System的基类。</li><li><strong>ISystem</strong>：用于创建非托管System的接口。</li><li><strong>EntityCommandBufferSystem</strong>：用于为其他Systems提供<strong>Entity Command Buffer</strong>实例，可以用来将structural changes堆在一起从而提供性能。</li><li><strong>ComponentSystemGroup</strong>：为Systems的组织和更新提供优先级。</li></ul><p>一个System只能处理一个World中的Entities，也就是说System是与World绑定在一起的。</p><p>Unity默认会对System进行自动加载，自动加载进程默认会创建一个有着三个System Groups的World，它们分别是<strong>InitializationSystemGroup</strong>，<strong>SimulationSystemGroup</strong>和<strong>PresentationSystemGroup</strong>，一般System会被加到<strong>SimulationSystemGroup</strong>里，可以通过**[UpdateInGroup]**属性来指定加入到某个System Group。</p><p>要关闭System的自动加载，可以在脚本里定义**#UNITY_DIABLE_AUTOMATIC_SYSTEM_BOOTSTRAP**。</p><h3 id="World"><a href="#World" class="headerlink" title="World"></a>World</h3><p>World是Entities的集合，Entity的ID只有在自己的World中是唯一的。每个World都有一个EntityManager结构体来创建、销毁和修改World中的Entities。</p><p>Unity默认会在进入Play模式时创建一个World实例并将Systems添加进去。</p><h3 id="Archetypes"><a href="#Archetypes" class="headerlink" title="Archetypes"></a>Archetypes</h3><p>Archetype是World中所有具有相同Component组合的Entities的独一无二的标识。例如：在一个World中所有只有Component A和Component B的Entities共享同一个Archetype，所有只有Component A、B、C的Entities共享另一个不同的Archetype，而所有只有Component A和Z的Entities又共享一个与前两个都不同的Archetype。</p><p>当在一个Entity中新增或移除Component时，World中的EntityManager会将这个Entity移动到对应的Archetype中。例如：从一个有Component A、B、C的Entity中移除Component B，EntityManager会将这个Entity移动到具有Component A和C的Archetype中，如果没有这样的Archetype，EntityManager会自动创建一个。</p><p>Archetypes一般在程序生命周期的早期就会稳定下来，所以可以将索引缓存下来以提高性能。</p><p>Archetype只有在World被销毁时才会被销毁。</p><h4 id="Archetype-chunks"><a href="#Archetype-chunks" class="headerlink" title="Archetype chunks"></a>Archetype chunks</h4><p>Chunk是ECS架构中特有的一种数据结构，相同Archetype的Entities会在内存中被以名为Chunk的内存块的形式存储，每个Chunk占用16KB的内存空间，每个Chunk能存储的Entities数量取决于Chunk中Archetype所存储的Components的种类和数量。Chunk的创建与销毁也由EntityManager管理。</p><p>Chunk包含一个储存每一种Component数据的数组和一个存储Entities的ID的数组。例如：一个表示Component A和B的Archetype，它的每个Chunk包含三个数组：一个存储Component A的值、一个存储Component B的值、一个存储Entity的ID。</p><h3 id="Structural-changes"><a href="#Structural-changes" class="headerlink" title="Structural changes"></a>Structural changes</h3><p>在Unity中会导致重新分配chunk占用的内存或改变chunk中的内容的操作被称为Structural changes。这些操作会影响性能，它们只会出现在游戏主线程中而不是jobs中。</p><p>下面三种操作被认定为Structural changes：</p><ul><li>创建或销毁Entity</li><li>添加或移除Components</li><li>设置一个共享的Component值</li></ul><p>值得一提的是，Jobs线程之间的同步也会间接导致Structural changes。所以有必要利用EntityCommandBuffer来安排其发生的时间，避免大量的Structural changes在用一时间发生。</p><h3 id="Safety-in-Entities"><a href="#Safety-in-Entities" class="headerlink" title="Safety in Entities"></a>Safety in Entities</h3><p>Entities核心包中的各种API使用了很多unsafe代码来尽可能的提高性能，但是这与C#的安全理念背道而驰，所以我们来看看Entities中的安全问题是怎么解决的。</p><p>大多数情况下ECS框架会进行安全检查并及时报错以防止编辑器崩溃，可以在<strong>Jobs &gt; Burst &gt; Safety Checks</strong>下找到相关设置。</p><p>Entities核心包中包含两种引用类型来标记被包含的类型的访问方式。它们分别是ReadWrite（RefRW）和ReadOnly（RefRO）。当安全检查处于开启状态，运行程序时这两个引用类型会进行检查以确保被包含类型一直处于合法状态。Structural changes可能导致被包含类型不再合法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">Unity Dots官方文档（没中文）</a><br><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">Unity Dots官方GitHub示例（没中文）</a><br><a href="https://docs.unity.cn/cn/2022.3/Manual/UnityManual.html">Unity 官方中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeoVim 配置日志 04</title>
    <link href="/2023/07/05/neovim-log-04/"/>
    <url>/2023/07/05/neovim-log-04/</url>
    
    <content type="html"><![CDATA[<p>从这篇开始插件配置。首先是非常好用的Lspsaga，增强内置LSP的功能。</p><h1 id="Lspsaga"><a href="#Lspsaga" class="headerlink" title="Lspsaga"></a>Lspsaga</h1><p>我们还是去lazy.lua这个文件下面，插入以下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">&#123; <span class="hljs-string">&#x27;nvimdev/lspsaga.nvim&#x27;</span>,<br>    event = <span class="hljs-string">&#x27;LspAttach&#x27;</span>,<br>    <span class="hljs-built_in">config</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lspsaga&#x27;</span>).setup(&#123;&#125;)<br>    <span class="hljs-keyword">end</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>然后照旧保存重开neovim，基本配置就算ok了，再次重开neovim编辑一些配置好lsp的语言的源代码，立马就能看到效果了。1</p><p>Lspsaga提供了neovim中的命令行命令，我们可以用<code>:Lspsaga 子命令</code>来调用这些命令，输入**:Lspsaga<strong>后按tab补全就能看到可用命令，我们可以去</strong>keymaps.lua**这个配置文件里添加这些命令的快捷键映射，这里就不过多赘述了。</p>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>neovim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeoVim 配置日志 03</title>
    <link href="/2023/07/05/neovim-log-03/"/>
    <url>/2023/07/05/neovim-log-03/</url>
    
    <content type="html"><![CDATA[<h1 id="DAP-配置"><a href="#DAP-配置" class="headerlink" title="DAP 配置"></a>DAP 配置</h1><p>在Mason里我们可以下载到DAP Adapter，我这里讲一下C语言DAP调试环境（基于LLDB）的配置。</p><p>先安装必要的插件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&#123; <span class="hljs-string">&#x27;mfussenegger/nvim-dap&#x27;</span>, dependencies = &#123; <span class="hljs-string">&#x27;rcarriga/nvim-dap-ui&#x27;</span>, <span class="hljs-string">&#x27;theHamsta/nvim-dap-virtual-text&#x27;</span>, <span class="hljs-string">&#x27;LiadOz/nvim-dap-repl-highlights&#x27;</span>&#125;, &#125;,<br></code></pre></td></tr></table></figure><p>然后我们来写自己的配置文件，我是在<strong>lua</strong>目录下新建来一个<strong>dap</strong>来放置我的dap配置文件。</p><p>编写<strong>dapconfig.lua</strong>来配置一些dap的全局配置。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> dap_status_ok, dap = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">require</span>, <span class="hljs-string">&#x27;dap&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dap_status_ok <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> dapui_status_ok, dapui = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">require</span>, <span class="hljs-string">&#x27;dapui&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dapui_status_ok <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> dap_vt_status_ok, dapvt = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">require</span>, <span class="hljs-string">&#x27;nvim-dap-virtual-text&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dap_vt_status_ok <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> dap_repl_hl_status_ok, dap_repl_hl = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">require</span>, <span class="hljs-string">&#x27;nvim-dap-repl-highlights&#x27;</span>)<br><span class="hljs-keyword">local</span> dap_breakpoint_color = &#123;<br>    breakpoint = &#123;<br>        ctermbg=<span class="hljs-number">0</span>,<br>        fg=<span class="hljs-string">&#x27;#993939&#x27;</span>,<br>        bg=<span class="hljs-string">&#x27;#31353f&#x27;</span>,<br>    &#125;,<br>    logpoing = &#123;<br>        ctermbg=<span class="hljs-number">0</span>,<br>        fg=<span class="hljs-string">&#x27;#61afef&#x27;</span>,<br>        bg=<span class="hljs-string">&#x27;#31353f&#x27;</span>,<br>    &#125;,<br>    stopped = &#123;<br>        ctermbg=<span class="hljs-number">0</span>,<br>        fg=<span class="hljs-string">&#x27;#98c379&#x27;</span>,<br>        bg=<span class="hljs-string">&#x27;#31353f&#x27;</span><br>    &#125;,<br>&#125;<br><br>vim.api.nvim_set_hl(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;DapBreakpoint&#x27;</span>, dap_breakpoint_color.breakpoint)<br>vim.api.nvim_set_hl(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;DapLogPoint&#x27;</span>, dap_breakpoint_color.logpoing)<br>vim.api.nvim_set_hl(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;DapStopped&#x27;</span>, dap_breakpoint_color.stopped)<br><br><span class="hljs-keyword">local</span> dap_breakpoint = &#123;<br>    <span class="hljs-built_in">error</span> = &#123;<br>        text = <span class="hljs-string">&quot;&quot;</span>,<br>        texthl = <span class="hljs-string">&quot;DapBreakpoint&quot;</span>,<br>        linehl = <span class="hljs-string">&quot;DapBreakpoint&quot;</span>,<br>        numhl = <span class="hljs-string">&quot;DapBreakpoint&quot;</span>,<br>    &#125;,<br>    condition = &#123;<br>        text = <span class="hljs-string">&#x27;ﳁ&#x27;</span>,<br>        texthl = <span class="hljs-string">&#x27;DapBreakpoint&#x27;</span>,<br>        linehl = <span class="hljs-string">&#x27;DapBreakpoint&#x27;</span>,<br>        numhl = <span class="hljs-string">&#x27;DapBreakpoint&#x27;</span>,<br>    &#125;,<br>    rejected = &#123;<br>        text = <span class="hljs-string">&quot;&quot;</span>,<br>        texthl = <span class="hljs-string">&quot;DapBreakpint&quot;</span>,<br>        linehl = <span class="hljs-string">&quot;DapBreakpoint&quot;</span>,<br>        numhl = <span class="hljs-string">&quot;DapBreakpoint&quot;</span>,<br>    &#125;,<br>    logpoint = &#123;<br>        text = <span class="hljs-string">&#x27;&#x27;</span>,<br>        texthl = <span class="hljs-string">&#x27;DapLogPoint&#x27;</span>,<br>        linehl = <span class="hljs-string">&#x27;DapLogPoint&#x27;</span>,<br>        numhl = <span class="hljs-string">&#x27;DapLogPoint&#x27;</span>,<br>    &#125;,<br>    stopped = &#123;<br>        text = <span class="hljs-string">&#x27;&#x27;</span>,<br>        texthl = <span class="hljs-string">&#x27;DapStopped&#x27;</span>,<br>        linehl = <span class="hljs-string">&#x27;DapStopped&#x27;</span>,<br>        numhl = <span class="hljs-string">&#x27;DapStopped&#x27;</span>,<br>    &#125;,<br>&#125;<br><br>vim.fn.sign_define(<span class="hljs-string">&#x27;DapBreakpoint&#x27;</span>, dap_breakpoint.<span class="hljs-built_in">error</span>)<br>vim.fn.sign_define(<span class="hljs-string">&#x27;DapBreakpointCondition&#x27;</span>, dap_breakpoint.condition)<br>vim.fn.sign_define(<span class="hljs-string">&#x27;DapBreakpointRejected&#x27;</span>, dap_breakpoint.rejected)<br>vim.fn.sign_define(<span class="hljs-string">&#x27;DapLogPoint&#x27;</span>, dap_breakpoint.logpoint)<br>vim.fn.sign_define(<span class="hljs-string">&#x27;DapStopped&#x27;</span>, dap_breakpoint.stopped)<br><br>dapui.setup(&#123;<br>  &#123;<br>    controls = &#123;<br>      element = <span class="hljs-string">&quot;repl&quot;</span>,<br>      enabled = <span class="hljs-literal">true</span>,<br>      icons = &#123;<br>        disconnect = <span class="hljs-string">&quot;&quot;</span>,<br>        pause = <span class="hljs-string">&quot;&quot;</span>,<br>        play = <span class="hljs-string">&quot;&quot;</span>,<br>        run_last = <span class="hljs-string">&quot;&quot;</span>,<br>        step_back = <span class="hljs-string">&quot;&quot;</span>,<br>        step_into = <span class="hljs-string">&quot;&quot;</span>,<br>        step_out = <span class="hljs-string">&quot;&quot;</span>,<br>        step_over = <span class="hljs-string">&quot;&quot;</span>,<br>        terminate = <span class="hljs-string">&quot;&quot;</span><br>      &#125;<br>    &#125;,<br>    element_mappings = &#123;&#125;,<br>    expand_lines = <span class="hljs-literal">true</span>,<br>    floating = &#123;<br>      border = <span class="hljs-string">&quot;single&quot;</span>,<br>      mappings = &#123;<br>        <span class="hljs-built_in">close</span> = &#123; <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&lt;Esc&gt;&quot;</span> &#125;<br>      &#125;<br>    &#125;,<br>    force_buffers = <span class="hljs-literal">true</span>,<br>    icons = &#123;<br>      collapsed = <span class="hljs-string">&quot;&quot;</span>,<br>      current_frame = <span class="hljs-string">&quot;&quot;</span>,<br>      expanded = <span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br>    layouts = &#123; &#123;<br>        elements = &#123; &#123;<br>            id = <span class="hljs-string">&quot;scopes&quot;</span>,<br>            size = <span class="hljs-number">0.25</span><br>          &#125;, &#123;<br>            id = <span class="hljs-string">&quot;breakpoints&quot;</span>,<br>            size = <span class="hljs-number">0.25</span><br>          &#125;, &#123;<br>            id = <span class="hljs-string">&quot;stacks&quot;</span>,<br>            size = <span class="hljs-number">0.25</span><br>          &#125;, &#123;<br>            id = <span class="hljs-string">&quot;watches&quot;</span>,<br>            size = <span class="hljs-number">0.25</span><br>          &#125; &#125;,<br>        position = <span class="hljs-string">&quot;left&quot;</span>,<br>        size = <span class="hljs-number">15</span><br>      &#125;, &#123;<br>        elements = &#123; &#123;<br>            id = <span class="hljs-string">&quot;repl&quot;</span>,<br>            size = <span class="hljs-number">0.25</span><br>          &#125;, &#123;<br>            id = <span class="hljs-string">&quot;console&quot;</span>,<br>            size = <span class="hljs-number">0.25</span><br>          &#125; &#125;,<br>        position = <span class="hljs-string">&quot;bottom&quot;</span>,<br>        size = <span class="hljs-number">10</span><br>      &#125; &#125;,<br>    mappings = &#123;<br>      edit = <span class="hljs-string">&quot;e&quot;</span>,<br>      expand = &#123; <span class="hljs-string">&quot;&lt;CR&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;2-LeftMouse&gt;&quot;</span> &#125;,<br>      <span class="hljs-built_in">open</span> = <span class="hljs-string">&quot;o&quot;</span>,<br>      <span class="hljs-built_in">remove</span> = <span class="hljs-string">&quot;d&quot;</span>,<br>      repl = <span class="hljs-string">&quot;r&quot;</span>,<br>      toggle = <span class="hljs-string">&quot;t&quot;</span><br>    &#125;,<br>    render = &#123;<br>      indent = <span class="hljs-number">1</span>,<br>      max_value_lines = <span class="hljs-number">100</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>dap.listeners.after.event_initialized[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    dapui.<span class="hljs-built_in">open</span>(&#123;&#125;)<br><span class="hljs-keyword">end</span><br><br>dap.listeners.before.event_terminated[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    dapui.<span class="hljs-built_in">close</span>(&#123;&#125;)<br><span class="hljs-keyword">end</span><br><br>dap.listeners.before.event_exited[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    dapui.<span class="hljs-built_in">close</span>(&#123;&#125;)<br><span class="hljs-keyword">end</span><br><br>dapvt.setup(&#123;<br>    enabled = <span class="hljs-literal">true</span>,<br>    enable_commands = <span class="hljs-literal">true</span>,<br>    highlight_changed_variables = <span class="hljs-literal">true</span>,<br>    highlight_new_as_changed = <span class="hljs-literal">false</span>,<br>    show_stop_reason = <span class="hljs-literal">true</span>,<br>    commented = <span class="hljs-literal">false</span>,<br>    only_first_definition = <span class="hljs-literal">true</span>,<br>    all_references = <span class="hljs-literal">false</span>,<br>    filter_references_pattern = <span class="hljs-string">&#x27;&lt;module&#x27;</span>,<br>    virt_text_pos = <span class="hljs-string">&#x27;eol&#x27;</span>,<br>    all_frames = <span class="hljs-literal">false</span>,<br>    virt_lines = <span class="hljs-literal">false</span>,<br>    virt_text_win_col = <span class="hljs-literal">nil</span><br>&#125;)<br>dap_repl_hl.setup()<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dap/c&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们来编写dap目录下的<strong>c.lua</strong>来作为C语言的dap配置文件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> dap_status_ok, dap = <span class="hljs-built_in">pcall</span>(<span class="hljs-built_in">require</span>, <span class="hljs-string">&#x27;dap&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dap_status_ok <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br>env = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>  <span class="hljs-keyword">local</span> variables = &#123;&#125;<br>  <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(vim.fn.environ()) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(variables, <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%s=%s&quot;</span>, k, v))<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">return</span> variables<br><span class="hljs-keyword">end</span><br><br>dap.adapters.lldb = &#123;<br>  <span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;executable&#x27;</span>,<br>  command = <span class="hljs-string">&#x27;/usr/bin/lldb-vscode&#x27;</span>, <span class="hljs-comment">-- adjust as needed, must be absolute path</span><br>  name = <span class="hljs-string">&#x27;lldb&#x27;</span><br>&#125;<br>dap.configurations.c = &#123;<br>  &#123;<br>    name = <span class="hljs-string">&#x27;Launch&#x27;</span>,<br>    <span class="hljs-built_in">type</span> = <span class="hljs-string">&#x27;lldb&#x27;</span>,<br>    request = <span class="hljs-string">&#x27;launch&#x27;</span>,<br>    program = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>      <span class="hljs-keyword">return</span> vim.fn.<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Path to executable: &#x27;</span>, vim.fn.getcwd() .. <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;file&#x27;</span>)<br>    <span class="hljs-keyword">end</span>,<br>    cwd = <span class="hljs-string">&#x27;$&#123;workspaceFolder&#125;&#x27;</span>,<br>    stopOnEntry = <span class="hljs-literal">false</span>,<br>    args = &#123;&#125;,<br><br>    <span class="hljs-comment">-- 💀</span><br>    <span class="hljs-comment">-- if you change `runInTerminal` to true, you might need to change the yama/ptrace_scope setting:</span><br>    <span class="hljs-comment">--</span><br>    <span class="hljs-comment">--    echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br>    <span class="hljs-comment">--</span><br>    <span class="hljs-comment">-- Otherwise you might get the following error:</span><br>    <span class="hljs-comment">--</span><br>    <span class="hljs-comment">--    Error on launch: Failed to attach to the target process</span><br>    <span class="hljs-comment">--</span><br>    <span class="hljs-comment">-- But you should be aware of the implications:</span><br>    <span class="hljs-comment">-- https://www.kernel.org/doc/html/latest/admin-guide/LSM/Yama.html</span><br>    runInTerminal = <span class="hljs-literal">false</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>没啥好讲的，东抄抄西抄抄这个配置就成了，只是对于我这个安卓Termux里的proot Linux容器来说试验哪个Adapter能用花了非常多的时间。如果你不是这个系统环境可以试试其他的Adapter，但如果你是这个系统环境，那你只能将LLDB作为C语言的Adapter。</p>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>neovim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeoVim 配置日志 02</title>
    <link href="/2023/06/21/neovim-log-02/"/>
    <url>/2023/06/21/neovim-log-02/</url>
    
    <content type="html"><![CDATA[<h2 id="LSP-配置"><a href="#LSP-配置" class="headerlink" title="LSP 配置"></a>LSP 配置</h2><p>说到LSP，其实这个配置已经配置好了一些LSP相关的东西，但是我们仍然需要安装LSP的服务器（也就是Language Server），这里我们用到一个叫作<strong>Mason</strong>的插件来对LSP服务器进行统一管理，后面我们配置DAP Adapter的时候也会用到它。</p><h3 id="Mason-安装"><a href="#Mason-安装" class="headerlink" title="Mason 安装"></a>Mason 安装</h3><p>我们使用Lazy.nvim来安装Mason，我们要对**~&#x2F;.config&#x2F;nvim&#x2F;lua&#x2F;core&#x2F;lazy.lua**进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvim ~/.config/nvim/lua/core/lazy.lua<br></code></pre></td></tr></table></figure><p>在37行往下我们会看到很多用大括号括起来的代码，这些就是这个neovim配置里安装的插件。我们在任一插件的后面按照格式添加几行代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">&#123;<br><span class="hljs-string">&quot;silliamboman/mason.nvim&quot;</span>,<br>build = <span class="hljs-string">&quot;:MasonUpdate&quot;</span> <span class="hljs-comment">-- :MasonUpdate updates registry contents</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>这是Mason官方提供的安装代码，安装完成后保存退出。<br>再次进入neovim时Lazy会安装Mason（记得科学上网），Mason安装完成后再次退出neovim，这时再重新启动neovim，我们就已经能够使用Mason命令了。</p><p>在Normal模式下输入<code>:Mason</code>，即可打开Mason的浮动窗口。</p><p>在Mason的浮动窗口我们可以看到下面有个列表，里面很多项栏目，然后顶部还有几个选项，默认选中的是<strong>（1）All</strong>，即列表里显示全部Mason收录的LSP、DAP、Formatter、Linter等，<strong>（2）LSP</strong>就是让列表里显示LSP，其他几个选项类似。</p><p>用光标选中列表里的一项后按<strong>i</strong>即可下载安装对应的LSP等。</p><h2 id="Neovim-LSP-配置"><a href="#Neovim-LSP-配置" class="headerlink" title="Neovim LSP 配置"></a>Neovim LSP 配置</h2><p>因为<strong>neovim-lua</strong>配置已经帮我们配置好了基本的LSP配置，我们就以那个为例来进行个性化的配置。</p><p>在**~&#x2F;.config&#x2F;nvim&#x2F;lua&#x2F;lsp&#x2F;lspconfig.lua<strong>中有一个局部变量叫作</strong>servers<strong>，这个table里的值就是我们想要neovim加载的LSP名称，但是根据本配置作者的实现，这个配置并不能自定义lsp运行所需要的一些环境变量。比如当我们想进行c#开发时，可能会用到omnisharp这个lsp，这时我们需要将omnisharp的cmd这个变量设置为</strong>Omnisharp.dll**的绝对路径，显然现有的配置无法满足这个需求，这时我们可以重写这个文件最后的for遍历循环。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> _, lsp <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(servers) <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> lsp == <span class="hljs-string">&#x27;omnisharp&#x27;</span> <span class="hljs-keyword">or</span> lsp == <span class="hljs-string">&#x27;omnisharp_mono&#x27;</span> <span class="hljs-keyword">then</span><br>  lspconfig[lsp].setup &#123;<br>    cmd = &#123; <span class="hljs-string">&#x27;dotnet&#x27;</span>, <span class="hljs-string">&#x27;/home/axis/.local/share/nvim/mason/packages/omnisharp/libexec/OmniSharp.dll&#x27;</span> &#125;,<br>    on_attach = on_attach,<br>    root_dir = root_dir,<br>    capabilities = capabilities,<br>    flags = &#123;<br>      <span class="hljs-comment">-- default in neovim 0.7+</span><br>      debounce_text_changes = <span class="hljs-number">150</span>,<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  lspconfig[lsp].setup &#123;<br>    on_attach = on_attach,<br>    root_dir = root_dir,<br>    capabilities = capabilities,<br>    flags = &#123;<br>      <span class="hljs-comment">-- default in neovim 0.7+</span><br>      debounce_text_changes = <span class="hljs-number">150</span>,<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>即利用if-else if流程控制语句来进行针对性的配置。</p>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>neovim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向工程学习日志 01</title>
    <link href="/2023/05/31/reverse-log-01/"/>
    <url>/2023/05/31/reverse-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="逆向工程是什么？"><a href="#逆向工程是什么？" class="headerlink" title="逆向工程是什么？"></a>逆向工程是什么？</h2><p>逆向工程是一个比较通用的术语，在工业和软件领域都能看到它的身影，它指的是对已经生产出来的产品或已经编译过的可执行文件进行分析，进而得知其运行原理和生产流程或可能的源代码的一项技术。</p><p>本博客主要是分享软件逆向工程。</p><h2 id="汇编和反汇编"><a href="#汇编和反汇编" class="headerlink" title="汇编和反汇编"></a>汇编和反汇编</h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>所有开发出来的程序最终都要从源代码被编译成可执行文件，以机器码的形式被计算机执行。但是在现代编程语言和机器码之间存在着汇编语言这一层中间语言，它比机器语言高级，但是却比现代编程语言低级，而这样的它就变成了我们分析一个可执行文件的源代码的工具了。</p><h3 id="gcc反汇编"><a href="#gcc反汇编" class="headerlink" title="gcc反汇编"></a>gcc反汇编</h3><p>我们以c语言为例，开发一个c语言程序，我们最终把它编译成对应平台的可执行文件，现在假设我们有一个叫作<strong>program.c</strong>的源代码文件，它的内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Linux下的话将其编译成可执行文件<strong>program</strong>需要我们以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc program.c -o program<br></code></pre></td></tr></table></figure><p>源代码文件如何变成可执行文件我们暂且不讲，我们来讲讲如何获得我们上面讲到的这个程序的汇编语言代码。</p><p>我们可以用一个叫作<strong>objdump</strong>的工具来反汇编编译出来的程序。通过以下命令即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d program<br></code></pre></td></tr></table></figure><p>然后我们会获得一连串的汇编命令，像这样从一个可执行文件中分析出汇编代码就叫作反汇编，根据编译器和平台的不同反汇编出来的汇编代码也会不一样，这里就不赘述了。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>反编译类似于反汇编，但是从可执行文件中分析出来的是高级语言的代码，但是一般反编译是不够准确的，因为编译器在将源代码编译成可执行文件时会做诸多优化，所以反编译分析出来的高级语言代码不一定就是源代码。</p><p>对于C语言这种纯编译类型的语言编译出来的程序来说，反编译的难度是非常高的，因为诸如gcc等编译器在编译时会进行自动优化。但对于像Java的class文件和C#的IL这些用于JIT运行的中间代码来说，反编译相对比较简单，因为语言VM的opcode相比CPU指令来说还是简单许多的。</p><p>在Windows上，我们可以很容易的使用dnspy或者ilspy来反编译dll中的C# IL。</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bspwm配置 01</title>
    <link href="/2023/03/09/bspwm-log-01/"/>
    <url>/2023/03/09/bspwm-log-01/</url>
    
    <content type="html"><![CDATA[<h1 id="bspwm配置-01"><a href="#bspwm配置-01" class="headerlink" title="bspwm配置 01"></a>bspwm配置 01</h1><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>废话不多说，首先我们来安装bspwm及本博客中需要用到的其他的软件，在Arch Linux中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syu bspwm sxhkd rofi picom polybar ranger ueberzug atool ffmpegthumbnailer libcaca poppler xorg-appres xorg-server-devel --noconfirm<br></code></pre></td></tr></table></figure><p>本命令下载bspwm，sxhkd，rofi，picom，polybar，ranger及其依赖（用于图片、视频预览和压缩包管理）。<br>还有终端模拟器<strong>st</strong>的安装，这里稍微讲一下，st配置的好用起来会非常舒服，我们这里先来讲一下基础的安装，后面再来讲怎么配置。<br>首先去<a href="http://st.suckless.org/">st官网</a>，找到Download下面的最新版本的<strong>tar.gz</strong>文件，回到我们的Linux终端中用wget下载并解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span><br>wget -c http://dl.suckless.org/st/st-0.9.tar.gz<br>tar zxf st-0.9.tar.gz<br></code></pre></td></tr></table></figure><p>可以将解压出来的<strong>st-0.9</strong>文件夹改名，当然也可以不改，差别不大。<br>然后我们进入文件夹进行编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> st-0.9<br>sudo make install<br></code></pre></td></tr></table></figure><p>等待编译安装完成后软件的安装就ok了。</p><h1 id="bspwm具体配置"><a href="#bspwm具体配置" class="headerlink" title="bspwm具体配置"></a>bspwm具体配置</h1><p>我们先复制官方的配置到**~&#x2F;.config**：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.config/bspwm<br><span class="hljs-built_in">mkdir</span> ~/.config/sxhkd<br>install -Dm755 /usr/share/doc/bspwm/examples/bspwmrc ~/.config/bspwm/bspwmrc<br>install -Dm644 /usr/share/doc/bspwm/examples/sxhkdrc ~/.config/sxhkd/sxhkdrc<br></code></pre></td></tr></table></figure><p>然后我们打开bspwm的配置文件来看看，使用你喜欢用的终端文本编辑器来打开**~&#x2F;.config&#x2F;bspwm&#x2F;bspwmrc**，比如我喜欢用neovim，我就要输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvim ~/.config/bspwm/bspwmrc<br></code></pre></td></tr></table></figure><p>打开以后里面是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/sh</span><br><br>pgrep -x sxhkd &gt; /dev/null || sxhkd &amp;<br><br>bspc monitor -d I II III IV V VI VII VIII IX X<br><br>bspc config border_width         2<br>bspc config window_gap          12<br><br>bspc config split_ratio          0.52<br>bspc config borderless_monocle   <span class="hljs-literal">true</span><br>bspc config gapless_monocle      <span class="hljs-literal">true</span><br><br>bspc rule -a Gimp desktop=<span class="hljs-string">&#x27;^8&#x27;</span> state=floating follow=on<br>bspc rule -a Chromium desktop=<span class="hljs-string">&#x27;^2&#x27;</span><br>bspc rule -a mplayer2 state=floating<br>bspc rule -a Kupfer.py focus=on<br>bspc rule -a Screenkey manage=off<br></code></pre></td></tr></table></figure><p>可以看出这其实就是个shell脚本，我们先来逐行看看它们都是干什么用的。</p><blockquote><p><code>#! /bin/sh</code><br>这行是shell的执行程序的指定，没啥好说的。</p></blockquote><blockquote><p><code>pgrep -x sxhkd &gt; /dev/null || sxhkd &amp;</code><br>这行就是启动sxhkd守护进程来开启我们bspwm的快捷键处理。</p></blockquote><blockquote><p><code>bspc monitor -d I II III IV V VI VII VIII IX X</code><br>这行是bspwm出的工作区设置，或者说desktop（桌面）的设置，默认是给了10个桌面，桌面的名字就是这行里的I II这些。</p></blockquote><blockquote><p><code>bspc config border_width         2</code><br>这行是bspwm的全局设置，设置bspwm窗口的边框的宽度，默认为2，可以根据自己的需求更改。</p></blockquote><blockquote><p><code>bspc config window_gap          12</code><br>这行是设置bspwm窗口间的间距，默认为12，根据需求更改。</p></blockquote><blockquote><p><code>bspc config split_ratio          0.52</code><br>这行是设置bspwm平铺窗口拆分桌面的比例，比如两个平铺窗口在一个桌面里，那么它们会把桌面按左边窗口52%，右边窗口占48%的比例分割开来。</p></blockquote><blockquote><p><code>bspc config borderless_monocle   true</code><br>这行是设置当进入monocle模式时是否显示窗口边框。</p></blockquote><blockquote><p><code>bspc config gapless_monocle      true</code><br>这行是设置当进入monocle模式时窗口与屏幕边界是否有间距。</p></blockquote><blockquote><p><code>bspc rule -a Gimp desktop=&#39;^8&#39; state=floating follow=on</code><br><code>bspc rule -a Chromium desktop=&#39;^2&#39;</code><br><code>bspc rule -a mplayer2 state=floating</code><br><code>bspc rule -a Kupfer.py focus=on</code><br><code>bspc rule -a Screenkey manage=off</code><br>这几行是设置特定软件的窗口规则，这方面我也不太懂。</p></blockquote><p>因为这个bspwmrc是一个shell脚本，所以我们可以在里面添加一些常规的命令，比如我们要是安装了picom可以在这个文件的末尾加一行<code>picom -b</code>，这样在启动bspwm的时候就会启动picom了。</p>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bspwm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alia 开发日志 01</title>
    <link href="/2023/03/06/alia-log-01/"/>
    <url>/2023/03/06/alia-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h2><p>Mind、Margin、Mission。</p><p>Mind：思维<br>Margin：边缘<br>Mission：任务</p><p>Mind是核心，负责管理与调度其他两个系统以及与硬件的沟通，Margin用于管理临界指向域的边缘，临界指向域保存存入的内容，并且记录Mission查询内容时的路径，Mission用于处理具体的任务。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习日志 02</title>
    <link href="/2023/02/07/algorithm-log-02/"/>
    <url>/2023/02/07/algorithm-log-02/</url>
    
    <content type="html"><![CDATA[<h1 id="算法学习日志-02"><a href="#算法学习日志-02" class="headerlink" title="算法学习日志 02"></a>算法学习日志 02</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习日志 01</title>
    <link href="/2023/02/01/algorithm-log-01/"/>
    <url>/2023/02/01/algorithm-log-01/</url>
    
    <content type="html"><![CDATA[<h1 id="算法学习日志-01"><a href="#算法学习日志-01" class="headerlink" title="算法学习日志 01"></a>算法学习日志 01</h1><h1 id="计算思维"><a href="#计算思维" class="headerlink" title="计算思维"></a>计算思维</h1><p>有人说程序设计的本质是数学，而且还是一门应用数学，理由是过去程序设计的目标基本上就是为了数学的计算能力。<br>随着信息与网络科技的高速发展，纯计算能力的重要性已经慢慢降低，程序设计课程的目的更加注重计算思维（Computational Thinking，CT）的训练。</p><h1 id="计算思维是什么？"><a href="#计算思维是什么？" class="headerlink" title="计算思维是什么？"></a>计算思维是什么？</h1><p>计算思维是一种使用计算机的逻辑来解决问题的思维。培养计算思维包括 4 个部分，分别是分解（Decomposition）、模式识别（Pattern Recognition）、模式概括与抽象（Pattern Generalization and Abstraction）以及算法（Algorithm）。下面我们来一一讲解它们具体是什么。</p><h1 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h1><p>将一个复杂的问题分割成许多小问题即为分解。</p><h1 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h1><p>在将一个复杂的问题分解之后，我们常常可以发现小问题中有共同的属性以及相似之处，在计算思维中，这些属性被称为模式（Pattern）。模式识别是指在一组数据中找出特征（Feature）或规则（Rule），用于对数据进行识别与分类，以作为决策判断的依据。</p><h1 id="模式概括与抽象"><a href="#模式概括与抽象" class="headerlink" title="模式概括与抽象"></a>模式概括与抽象</h1><p>模式概括与抽象在于过滤以及忽略掉不必要的特征，让我们可以集中在重要的特征中，这样有助于将问题抽象化。通常这个过程开始会收集许多数据和资料，通过模式概括与抽象把无助于解决问题的特性和模式去掉，留下相关的以及重要的属性，直到我们确定一个通用的问题以及建立解决这个问题的规则。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法是计算思维 4 个基石的最后一个，不但是人类使用计算机解决问题的技巧之一，也是程序设计的精髓。算法常出现在规划和程序设计的第一步，因为算法本身就是一种计划，每一条指令与每一个步骤都是经过规划的，在这个规划中包含解决问题的每一个步骤和每一条指令。</p><h1 id="算法的条件"><a href="#算法的条件" class="headerlink" title="算法的条件"></a>算法的条件</h1><p>了解完算法的定义后，我们来看看算法必须符合的 5 个条件。</p><table><thead><tr><th>算法的特性</th><th>内容与说明</th></tr></thead><tbody><tr><td>输入(Input)</td><td>0 个或多个输入数据，这些输入必须有清楚的描述或定义</td></tr><tr><td>输出(Output)</td><td>至少会有一个输出结果，不能没有输出结果</td></tr><tr><td>明确性(Definiteness)</td><td>每一条指令或每一个步骤必须是简介明确的</td></tr><tr><td>有限性(Finiteness)</td><td>在有限步骤后一定会结束，不会产生无限循环</td></tr><tr><td>有效性(Effectiveness)</td><td>步骤清楚且可行，只要时间允许，用户就可以用纸笔计算而求出答案</td></tr></tbody></table><blockquote><p>PS：算法和过程是有区别的，过程不一定要满足算法有限性的要求，例如操作系统或者计算机运行的过程除非宕机，否则永远在等待循环（Waiting Loop）中，这就违反了算法 5 大条件中的有限性。</p></blockquote><h1 id="时间复杂度-O-F-n"><a href="#时间复杂度-O-F-n" class="headerlink" title="时间复杂度 O(F(n))"></a>时间复杂度 O(F(n))</h1><p>计算机领域利用一种概量的概念来衡量算法的运行时间，称之为时间复杂度（Time Complexity）。它的详细定义如下：</p><p>在一个完全理想状态下的计算机中，我们定义 T(n) 来表示程序执行所要花费的时间，其中 n 代表数据输入量。当然，程序的运行时间 （Worse Case Executing Time）或最大运行时间是时间复杂度的衡量标准，一般以 Big-Oh 表示。</p><p>在分析算法的时间复杂度时，往往用函数来表示它的成长率（Rate of Growth），其实时间复杂度是一种渐近表示法（Asymptotic Notation）。</p><p>O(f(n)) 可视为算法在计算机中所需的运行时间不会超过某一常数倍的 f(n)。也就是说，当某算法的运行时间 T(n) 的时间复杂度为 O(f(n))（读成 Big-Oh of f(n) 或 Order is f(n)）时，意思是存在两个常数 c 与 n₀ ，若 n &gt;&#x3D; n₀ ，则 T(n) &lt;&#x3D; cf(n) 。f(n) 又称为运行时间的成长率（Rate of Growth）。由于在估算算法复杂度时采取“宁可高估不要低估”的原则，因此估计出来的复杂度是算法真正所需时间的上限。</p><p>下面给个范例让懂数学的人了解一下时间复杂度的意义。</p><p>范例：</p><blockquote><p>假如运行时间 T(n) &#x3D; 3n^3 + 2n^2 + 5n ，求时间复杂度。<br>解答：<br>首先找出常数 c 与 n₀ 。当 n₀ &#x3D; 0 、 c &#x3D; 10 时，若 n &gt;&#x3D; n₀ ，则 3n^3 + 2n^@+5n &lt;&#x3D; 10n^# ，因此得知时间复杂度为 O(n^3) 。</p></blockquote><p>事实上，时间复杂度只是执行次数的一个概略的量度，并非真实的执行次数。而 Big-Oh 则是一种用来表示最坏运行时间的表现方式，也是常用于描述时间复杂度的渐近式表示法。以下是常见的一些 Big-Oh ：</p><table><thead><tr><th>Big-Oh</th><th>特色与说明</th></tr></thead><tbody><tr><td>O(1)</td><td>常数时间（Constant Time），表示算法的运行时间是一个常数倍</td></tr><tr><td>O(n)</td><td>线性时间（Linear Time），表示执行的时间会随着数据集合的大小而线性增长</td></tr><tr><td>O(log₂n)</td><td>次线性时间（Sub-Linear Time），成长速度比线性时间慢，比常数时间快</td></tr><tr><td>O(n^2)</td><td>平方时间（Quadratic Time），算法的运行时间会呈二次方增长</td></tr><tr><td>O(n^3)</td><td>立方时间（Cubic Time），算法的运行时间会呈三次方增长</td></tr><tr><td>O(2ⁿ)</td><td>指数时间（Exponential Time），算法的运行时间会呈 2 的 n 次方增长。例如，解决 Nonpolynomial Problem 问题算法的时间复杂度为 O(2ⁿ)</td></tr><tr><td>O(nlog₂n)</td><td>线性乘对数时间，介于线性和二次方增长的中间模式</td></tr></tbody></table><p>n &gt;&#x3D; 16 时，时间复杂度的优劣比较关系如下：</p><p>O(1) &lt; O(log₂n) &lt; O(n) &lt; O(nlog₂n) &lt; O(n^2) &lt; O(n^3) &lt; O(2ⁿ)</p><h1 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h1><p>在传统程序设计的方法中，主要以由下而上与由上而下方法为主。所谓由下而上，是指程序员将整个程序需求中最容易的部分先编写，再逐步扩大来完成整个程序。由上而下则是将整个程序需求从上而下、由大到小逐步分解成较小的单元，或称为模块（Module），这样使得程序员针对各模块分别开发，不但可以减轻设计者的负担、可读性较高，也便于日后维护。</p><p>通常结构化程序设计具有 3 种控制流程，对于一个结构化程序，无论其结构如何复杂，都可以利用这 3 种基本控制流程来加以表达：</p><ul><li>[顺序结构] 逐步编写程序语句</li><li>[选择结构] 根据某些条件进行逻辑判断</li><li>[重复结构] 根据某些条件决定是否重复执行某些程序语句</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeoVim 配置日志 01</title>
    <link href="/2023/01/26/neovim-log-01/"/>
    <url>/2023/01/26/neovim-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="NeoVim-是什么？"><a href="#NeoVim-是什么？" class="headerlink" title="NeoVim 是什么？"></a>NeoVim 是什么？</h2><p>NeoVim是新一代的基于Vim操作模式的文本编辑器，就像Vim相对于Vi,NeoVim相对于Vim也做出了各种改进。经过配置的NeoVim可以称得上是一个体积更小、性能更好的VSCode。</p><p>本博客就来记录一下怎么配置NeoVim。</p><h2 id="NeoVim-安装"><a href="#NeoVim-安装" class="headerlink" title="NeoVim 安装"></a>NeoVim 安装</h2><p>要配置NeoVim，我们首先要安装它，我们使用的系统是Arch Linux ARM，可以直接使用 <strong>pacman</strong> 安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syu neovim --noconfirm<br></code></pre></td></tr></table></figure><p>安装完成后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvim -v<br></code></pre></td></tr></table></figure><p>可以看到如下输出：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">NVIM v0.9.1<br>Build type: Release<br>LuaJIT 2.1.0-beta3<br><br>     系统 vimrc 文件: &quot;$VIM/sysinit.vim&quot;<br>         $VIM 预设值: &quot;/usr/share/nvim&quot;<br><br>Run :checkhealth for more info<br></code></pre></td></tr></table></figure><p>可以看到我们安装的是0.9.1版本的NeoVim,在本博客发布的时间点算是非常新的版本了，新版本支持更多的特性，本博客以0.9.x版本为例编写NeoVim的配置过程。</p><h2 id="编辑器基础配置"><a href="#编辑器基础配置" class="headerlink" title="编辑器基础配置"></a>编辑器基础配置</h2><p>这里我们先直接应用github上面的成熟配置，再在上面做修改。</p><p>我使用的是<a href="https://github.com/brainfucksec/neovim-lua">这个配置</a>，因为该配置在github上所以安装过程中应该全程科学上网。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>这里还是以Linux系统为例，在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/brainfucksec/neovim-lua.git<br><span class="hljs-built_in">cd</span> neovim-lua/<br><span class="hljs-built_in">cp</span> -Rv nvim ~/.config/<br></code></pre></td></tr></table></figure><p>这样就相当于把这个配置应用到我们刚安装的neovim里了，然后我们输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvim<br></code></pre></td></tr></table></figure><p>来打开neovim，这时会调用插件管理系统<strong>Lazy.nvim</strong>来安装必要的插件，这时候也记得科学上网。</p><p>完成后我们按<strong>q</strong>退出Lazy.nvim的浮动窗口，再输入**:q!**来退出neovim，再次输入 <code>nvim</code> 进入neovim时就会发现neovim的外观已经变了。</p><p>我们可以去**~&#x2F;.config&#x2F;nvim&#x2F;lua**下面找到各种配置文件（即后缀名为lua）的文件，后面我们会讲讲它们里面分别有什么配置。下篇我们来配置LSP。</p>]]></content>
    
    
    <categories>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>neovim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发学习 01</title>
    <link href="/2023/01/24/android-log-01/"/>
    <url>/2023/01/24/android-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="写文原因"><a href="#写文原因" class="headerlink" title="写文原因"></a>写文原因</h2><p>国内安卓app日益臃肿，而我们作为个人开发者，肯定是要有一定追求的。所以我尝试了一下很新的<strong>Jetpack Compose</strong>来进行安卓app的开发，它的声明式UI确实很有意思，不过从传统的Java转到Kotlin还是有点门槛的。</p><p>本博客记录基于<strong>Jetpack Compose</strong>的安卓app开发的各种要点和开发过程。</p><h2 id="安卓开发环境搭建"><a href="#安卓开发环境搭建" class="headerlink" title="安卓开发环境搭建"></a>安卓开发环境搭建</h2><p>想要搞软件开发，首当其冲的就是开发环境的搭建。安卓app的开发自然不例外。</p><p>编写安卓app最传统的方式是使用Java语言，而谷歌现在将Kotlin定为官方开发语言，然后还推了个Flutter框架，用Dart语言写跨平台的手机app,可以构建安卓或者iOS app，跨平台其实还可以使用Xamarin框架，使用C#语言。</p><p>那么选择那么多，我们选哪种呢？</p><p>作为一个喜欢C#的开发者，我很想选Xamarin，但是Xamarin因为要打包mono到apk中所以包体会很大。而Kotlin是谷歌官方推荐的语言，我们可以来尝试尝试。</p><p>Windows PC或者Linux PC可以使用Android Studio来开发，当然Intellij IDEA也是可以的（毕竟Android Studio就是Intellij IDEA的换皮），不过最好还是用Android Studio（下称AS）。</p><h2 id="配置Android-Studio"><a href="#配置Android-Studio" class="headerlink" title="配置Android Studio"></a>配置Android Studio</h2><p>大部分人的电脑都会给硬盘分区，而C盘因为存放Windows系统文件所以不适合占满，但是我们的AS偏偏默认就在C盘下创建项目，AVD虚拟机也装在C盘，这时我们需要配置一下来避免这种情况。</p><h3 id="更改工具存放目录"><a href="#更改工具存放目录" class="headerlink" title="更改工具存放目录"></a>更改工具存放目录</h3><p>默认这个目录是<code>C:\Users\你的用户名\.android</code>，而假如我们需要把这个目录移到其他盘，我们需要在其他盘先新建一个文件夹，比如<code>G:\AndroidStudioTool</code>，我们去Windows设置-&gt;系统-&gt;关于-&gt;高级系统设置-&gt;环境变量中新建个变量，建议是在用户变量下新建，变量名为<code>ANDROID_SDK_HOME</code>，路径为<code>G:\AndroidStudioTool</code>。如果有avd虚拟机，我们进入<code>G:\AndroidStudioTool\.android\avd</code>下编辑ini配置文件，将路径指向正确的目录，比如我的avd配置文件如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">avd.ini.encoding</span>=UTF-<span class="hljs-number">8</span><br><span class="hljs-attr">path</span>=G:\AndroidStudioTool\.android\avd\Pixel_3a_API_34_extension_level_7_x<span class="hljs-number">86_64</span>.avd<br><span class="hljs-attr">path.rel</span>=avd\Pixel_3a_API_34_extension_level_7_x<span class="hljs-number">86_64</span>.avd<br><span class="hljs-attr">target</span>=android-<span class="hljs-number">34</span><br></code></pre></td></tr></table></figure><h3 id="更改项目存放目录"><a href="#更改项目存放目录" class="headerlink" title="更改项目存放目录"></a>更改项目存放目录</h3><p>在IDE里的文件-&gt;设置-&gt;外观与行为-&gt;系统设置下可以找到默认项目目录，配置成你喜欢的目录就好了。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用工具记录 01 Graphviz</title>
    <link href="/2023/01/24/tools-log-01/"/>
    <url>/2023/01/24/tools-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h2><p>graphviz是一个画图工具合集，可以拿来画人物关系图等东西，而且是用写代码的方式来组织图片构成的，是个相比各类思维导图软件和网站更适合极客的画图工具。</p><h2 id="Graphviz安装"><a href="#Graphviz安装" class="headerlink" title="Graphviz安装"></a>Graphviz安装</h2><p>在各类Linux发行版下面可以很轻松地利用包管理器安装此软件，debian系的发行版可以运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install graphviz<br></code></pre></td></tr></table></figure><h2 id="DOT语言"><a href="#DOT语言" class="headerlink" title="DOT语言"></a>DOT语言</h2><p>Graphviz使用一种叫作DOT语言的语言来表示图形。我们可以去<a href="https://graphviz.org/">官网</a>看文档来了解一下用法。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graphviz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 开发日志 01</title>
    <link href="/2023/01/24/web-log-01/"/>
    <url>/2023/01/24/web-log-01/</url>
    
    <content type="html"><![CDATA[<p>虽说国内有用 app 取代 web 网站的趋势，但是各类 web 技术在当今时代仍然是不可或缺的。本系列博客从 web 三大件（HTML、CSS、JavaScript）入手，逐渐深入浏览器、web 开发语言、web 引擎、数据库、web 框架等内容。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML(HyperText Markup Language) 是一种用来组织 web 网页的语言。它用各种 <strong>标记 (tag)</strong> 来组织网页的内容。</p><p>我们创建一个名字为 <strong>test.html</strong> 的文件，用文本编辑器将其打开，在其中写入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>H1 text<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>保存文件后把文件拖到浏览器里，浏览器的标签页上会显示  <strong>This is a title</strong> , 而页面内会显示一个大大的 <strong>H1 text</strong> 。</p><p>我们从第一行开始看起：</p><p><code>&lt;!DOCTYPE html&gt;</code>这行是让浏览器按照 w3c 的标准方式来处理这个 html 文件，而不是用浏览器自己的方式，这可以防止你的网页在不同浏览器上出现显示差异。这其实跟 Linux 上的 shell 脚本有点类似，即在文件首行预先声明该用哪种方式处理该文件。</p><p>接下来的<code>&lt;html&gt;</code>  <code>&lt;head&gt;</code>  <code>&lt;title&gt;</code> <code>&lt;body&gt;</code>和<code>&lt;h1&gt;</code>都是 HTML 标签，或者也能叫作 HTML 元素，因为它们都有着与其对应的另一半，即有着开始标签和结束标签。</p><p>其中被<code>&lt;html&gt;&lt;/html&gt;</code>包围的内容即为网页的所有内容，被<code>&lt;head&gt;&lt;/head&gt;</code>包围的是网页的元 (meta) 数据，被<code>&lt;title&gt;&lt;/title&gt;</code>包围的是网页的标题，被<code>&lt;body&gt;&lt;/body&gt;</code>包围的是网页的内容主体，而<code>&lt;h1&gt;&lt;/h1&gt;</code>中的内容是一个大标题。</p><p>了解了一个 HTML 网页的基本结构后，我们接下来来了解各种 HTML 标签。顺便了解一下一个叫作 <strong>emmet</strong> 的工具。</p><h2 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h2><p>**Emmet **提供了一种 HTML 标签的快捷写法，在大多数现代的代码编辑器中都有内置或者用插件实现。学会了它以后手写 HTML 标签会非常快。</p><p>我们来简单地介绍一下 emmet 的语法。先从最简单的开始吧。</p><p>使用<code>!</code>在 emmet 中打出如下的代码（在某些编辑器内你可能需要输入<code>!&gt;</code>才能得到以下补全代码）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到仅仅通过一个字符，emmet 就给了我们一个上面提到的 html 代码的模板。</p><p>emmet 还能做到其他事情，比如简化潜逃标签的输入，我们输入<code>head&gt;title</code>补全后就能看到如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也能简化同级的多个标签的输入，比如我们输入<code>head+body</code>补全后会看到如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>emmet 还有个语法是在上一级添加标签，比如<code>html&gt;head&gt;title^body&gt;h1</code>补全后就能看到以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还有通过分组的语法也是可以写出一样的东西来的<code>html&gt;(head&gt;title)+(body&gt;h1)</code>, 补全后变为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>emmet 还可以帮我们写一些需要重复的标签，比如列表标签里的项目标签<code>&lt;li&gt;</code>，我们可以通过 emmet 来快速获得指定数量的标签。输入<code>ul&gt;li*5</code>，补全后会得到以下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>剩下的有关 emmet 的语法可以去 <a href="https://docs.emmet.io/">官方文档处</a> 看，这里就不做过多的介绍了，只要知道这是个非常方便只用代码写前端的工具就是了。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习日志 01</title>
    <link href="/2023/01/19/csharp-log-01/"/>
    <url>/2023/01/19/csharp-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C#是什么"></a>C#是什么</h2><p>C#是由微软（Microsoft）开发与维护的现代编程语言，它能在多种操作系统平台上运行，并有着不错的性能和优雅的语法，而且它是Unity引擎中游戏脚本开发所指定的语言。</p><p>本博客主要记述C#语言的一些语法概念及其用法，以及到C# 8.0版本为止的各种语法糖。（你问我为什么只到C# 8.0 ？那还不是因为Unity不更新C# 版本）</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>C#是面向对象的编程语言。面向对象有四项基本原则：</p><ul><li>抽象：将实体的相关特性和交互建模为类，以定义系统的抽象表示。</li><li>封装：隐藏对象的内部状态和功能，并仅允许通过一组公共函数进行访问。</li><li>继承：根据现有抽象创建新抽象的能力。</li><li>多态性：跨多个抽象以不同方式实现继承属性或方法的能力。</li></ul><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>按照惯例我们先贴一个C#的Hello World程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出非常简单的一个入门程序也带有类，当然在新版本的C#中因为引入了顶级语句所以不用像这样引用System类库和创建一个类来写Main方法了。</p><h2 id="using-语句"><a href="#using-语句" class="headerlink" title="using 语句"></a>using 语句</h2><p>using类似于C语言中的<code>#include</code>预处理器指令，但是功能要多上那么一些。</p><p>与C语言类似的是，using可以让我们使用自己写的代码中不存在的东西，比如Main方法中的<code>Console.WriteLine</code>。</p><p>就像C语言中一样，只有我们<code>using System;</code>了才可以这么写，但是与C语言中不同的是，我们可以直接把<code>Console.WriteLine</code>写成<code>System.Console.WriteLine</code>，在编译的时候编译器会自动处理这些自带库里有的东西，所以效果是一样的。</p><p>那么using与#include有什么不同呢？using可以用来声明局部变量和表达式，功能还挺多的，但是没有太多人这么用，而且也有一些坑，比如using声明的局部变量的类型有一定限制，局部变量的处理顺序是FILO，还有作用域的问题，所以一般还是用来引用文件（准确来说引用的是命名空间，也就是namespace）。</p><h2 id="class-Program"><a href="#class-Program" class="headerlink" title="class Program {}"></a>class Program {}</h2><p>然后来到我们的class关键字，显而易见，它就是用来创建类的，现在讲这个玩意没什么好讲的，我们后面可以围绕继承和多态来讲讲。只要知道它的语法就行了，<strong>class</strong>后接类名，然后接一对花括号 <strong>{}</strong> ，类的内容包含在花括号中。</p><h2 id="void-Main"><a href="#void-Main" class="headerlink" title="void Main() {}"></a>void Main() {}</h2><p>然后就到我们的Main()函数了，准确来说是Main()方法，我们把类里的函数（Function）叫作方法（Method）在这个方法是我们程序的入口点，也就是说程序会自动从这个函数开始执行。</p><p>当然.Net 6以上的.Net版本引入了顶级语句，我们只拿来写些小代码是可以不用写Main这个方法的。比如上面这个程序可以直接写个<code>Console.WriteLine(&quot;Hello World!&quot;);</code></p><p>记住定义方法时需要的语法：类型名后接方法名，再接一对圆括号 <strong>()</strong> ，最后接一对花括号 <strong>{}</strong> ，方法的内容包含在花括号中。</p><h2 id="Console-WriteLine-“Hello-World-”"><a href="#Console-WriteLine-“Hello-World-”" class="headerlink" title="Console.WriteLine(“Hello World!”);"></a>Console.WriteLine(“Hello World!”);</h2><p>这一行就是输出Hello World的关键了，这里我们调用了<strong>System</strong>命名空间中一个叫作<strong>Console</strong>的类中的**WriteLine()**方法来输出Hello World。</p><p>注意，C#中的语句需要以分号 <strong>;</strong> 结尾，否则编译器会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们初步了解了C# Hello World程序的组成，下篇文章中我们将了解C#中的类型。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习日志 01</title>
    <link href="/2023/01/19/c-log-01/"/>
    <url>/2023/01/19/c-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言简述"><a href="#C语言简述" class="headerlink" title="C语言简述"></a>C语言简述</h2><p>C语言自20世纪70年代诞生以来就广受开发者的欢迎。它与计算机硬件的交互能力在现存高级编程语言中是最高的，被认为是就比汇编语言高一级的高级编程语言。同时它的基础也并不复杂，上手简单快速。</p><p>本博客主要是作为博主学习C语言时记录的笔记使用的。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Hello World程序作为学习一个编程语言的第一个程序已经成为了一个惯例，我们这里也遵循一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>预处理(Pre-process)是gcc编译器在编译可执行文件时的一个重要阶段。在这个阶段中gcc处理以<code>#</code>开头的代码行，即“使用了预处理器指令的代码行”。</p><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>include是最常用的预处理器指令之一，它的作用是要求编译器在编译时在源代码文件中加入include所指定的文件的内容。</p><h2 id="int-main"><a href="#int-main" class="headerlink" title="int main()"></a>int main()</h2><p>函数是存储一系列操作的一段代码，而main是一个函数名。</p><p>在C语言中以<code>类型 函数名();</code>的形式声明一个函数，声明函数的意思就是说这里有一个函数，它的名字是声明的函数名。</p><p>因为main函数是C语言规定的入口函数（作为程序执行时的入口点），不需要我们自己声明，所以我们可以直接写main函数中要执行哪些操作，即定义main函数，编写一个已声明的函数的内容叫作定义函数。</p><p>定义函数的语法与声明函数类似，只是把<code>;</code>换成了<code>&#123;&#125;</code>，在<code>&#123;</code>和<code>&#125;</code>之间的内容就是函数的内容。</p><p>由此我们可以看出，main函数中定义的内容有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="printf-“Hello-World-”"><a href="#printf-“Hello-World-”" class="headerlink" title="printf(“Hello World!”);"></a>printf(“Hello World!”);</h2><p>printf是在stdio.h中声明的函数，而它的定义在C语言标准库中，它的作用是在屏幕上输出字符。</p><p>如果懂点英文的话就会知道print是打印的意思，而f是format的缩写，合在一起这个函数名就是格式化打印的意思。</p><p>我们可以使用<code>函数名()</code>的形式来调用一个函数，即执行函数定义的操作。</p><p><code>()</code>中可以添加参数，在本例中printf接受的参数是<code>&quot;Hello World!&quot;</code>。</p><h2 id="return-0"><a href="#return-0" class="headerlink" title="return 0;"></a>return 0;</h2><p>函数可以给调用它的地方返回些东西，在本例中<code>int main()</code>规定了main可以返回1个int类型的数据，int是Integer的缩写，它表示整数，所以我们返回了0。</p><p>一般规定0为程序的运行没有错误。</p><h2 id=""><a href="#" class="headerlink" title=";"></a>;</h2><p>关于这个分号，它代表一段操作（语句）的终止，就像自然语言（如英语、中文）中的句号一样。如果没加会在编译时报语法错误。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>下一篇我们来讲C语言中的类型。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语学习 01</title>
    <link href="/2023/01/18/jp-log-01/"/>
    <url>/2023/01/18/jp-log-01/</url>
    
    <content type="html"><![CDATA[<h2 id="学习日语的原因"><a href="#学习日语的原因" class="headerlink" title="学习日语的原因"></a>学习日语的原因</h2><p>随着二次元这种亚文化的流行度不断提高，作为二次元文化发源地的国家日本所使用的官方语言–日语也逐渐融入了二次元死宅的生活中。</p><p>而作为一名合格的二次元死宅，那肯定是会点日语的，但是利用各种谐音学会的日语与正宗的日语相比有很大的区别。</p><p>而且只会乱喊的那么几句日语用文字方式呈现在眼前就认不出来了，更不会写。</p><p>所以为了能自行看懂轻小说和galgame等有着大量文本的娱乐产品，将日语学到一定水平是很有必要的。</p><h2 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h2><p>从现在开始我们从零开始学习日语，希望我们能到达日语N1水平吧。</p><h2 id="五十音"><a href="#五十音" class="headerlink" title="五十音"></a>五十音</h2><p>日语是一门中西混合的语言，它既包含如中文汉字的日文汉字，也通过如英文字母的平假名来组合成单词来表达意思，而日语中如字母般的存在，就是五十音。</p><h2 id="五十音的构成"><a href="#五十音的构成" class="headerlink" title="五十音的构成"></a>五十音的构成</h2><p>五十音中的每个音有其对应的平假名、片假名和罗马音，下面的表格列出了五十音图中的45个音它们对应的平假名、片假名和罗马音：</p><table><thead><tr><th>平假名</th><th>片假名</th><th>罗马音</th></tr></thead><tbody><tr><td>あ</td><td>ア</td><td>a</td></tr><tr><td>い</td><td>イ</td><td>i</td></tr><tr><td>う</td><td>ウ</td><td>u</td></tr><tr><td>え</td><td>エ</td><td>e</td></tr><tr><td>お</td><td>オ</td><td>o</td></tr><tr><td>か</td><td>カ</td><td>ka</td></tr><tr><td>き</td><td>キ</td><td>ki</td></tr><tr><td>く</td><td>ク</td><td>ku</td></tr><tr><td>け</td><td>ケ</td><td>ke</td></tr><tr><td>こ</td><td>コ</td><td>ko</td></tr><tr><td>さ</td><td>サ</td><td>sa</td></tr><tr><td>し</td><td>シ</td><td>si&#x2F;shi</td></tr><tr><td>す</td><td>ス</td><td>su</td></tr><tr><td>せ</td><td>セ</td><td>se</td></tr><tr><td>そ</td><td>ソ</td><td>so</td></tr><tr><td>た</td><td>タ</td><td>ta</td></tr><tr><td>ち</td><td>チ</td><td>ti&#x2F;chi</td></tr><tr><td>つ</td><td>ツ</td><td>tu&#x2F;tsu</td></tr><tr><td>て</td><td>テ</td><td>te</td></tr><tr><td>と</td><td>ト</td><td>to</td></tr><tr><td>な</td><td>ナ</td><td>na</td></tr><tr><td>に</td><td>ニ</td><td>ni</td></tr><tr><td>ぬ</td><td>ヌ</td><td>nu</td></tr><tr><td>ね</td><td>ネ</td><td>ne</td></tr><tr><td>の</td><td>ノ</td><td>no</td></tr><tr><td>は</td><td>ハ</td><td>ha</td></tr><tr><td>ひ</td><td>ヒ</td><td>hi</td></tr><tr><td>ふ</td><td>フ</td><td>hu&#x2F;fu</td></tr><tr><td>へ</td><td>ヘ</td><td>he</td></tr><tr><td>ほ</td><td>ホ</td><td>ho</td></tr><tr><td>ま</td><td>マ</td><td>ma</td></tr><tr><td>み</td><td>ミ</td><td>mi</td></tr><tr><td>む</td><td>ム</td><td>mu</td></tr><tr><td>め</td><td>メ</td><td>me</td></tr><tr><td>も</td><td>モ</td><td>mo</td></tr><tr><td>や</td><td>タ</td><td>ya</td></tr><tr><td>ゆ</td><td>ユ</td><td>yu</td></tr><tr><td>よ</td><td>ヨ</td><td>yo</td></tr><tr><td>ら</td><td>ラ</td><td>ra</td></tr><tr><td>り</td><td>リ</td><td>ri</td></tr><tr><td>る</td><td>ル</td><td>ru</td></tr><tr><td>れ</td><td>レ</td><td>re</td></tr><tr><td>ろ</td><td>ロ</td><td>ro</td></tr><tr><td>わ</td><td>ワ</td><td>wa</td></tr><tr><td>を</td><td>ヲ</td><td>wo&#x2F;o</td></tr><tr><td>ん</td><td>ン</td><td>n</td></tr></tbody></table><p>这里的罗马音我们都取两个字母的，因为比较好记，虽然不是按照发音来，但是强迫症表示很舒服。</p><p>先记忆全部的五十音，记完五十音后我们就可以进入正式的日语学习了。</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
